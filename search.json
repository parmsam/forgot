[{"path":"https://parmsam.github.io/forgot/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 forgot authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://parmsam.github.io/forgot/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sam Parmar. Maintainer.","code":""},{"path":"https://parmsam.github.io/forgot/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parmar S (2023). forgot: Function Reference Search Console. R package version 0.1.0, https://parmsam.github.io/forgot/.","code":"@Manual{,   title = {forgot: Function Reference Search In Console},   author = {Sam Parmar},   year = {2023},   note = {R package version 0.1.0},   url = {https://parmsam.github.io/forgot/}, }"},{"path":"https://parmsam.github.io/forgot/index.html","id":"forgot-","dir":"","previous_headings":"","what":"Function Reference Search In Console","title":"Function Reference Search In Console","text":"goal forgot help search one function need one package. package based functions Rd2roxygen. forgot() function returns tibble section content R documentation files specified package (’s already installed). can search tibble return interactive HTML table needed. ’s also RStudio Addin included can use search package documentation small Shiny app. forgot2() casual use return simple version forgot tibble just first two columns default. package provides alternative function search without using help system (?help()) RStudio IDE. still use though learning purposes.","code":""},{"path":"https://parmsam.github.io/forgot/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Function Reference Search In Console","text":"can install development version forgot like :","code":"# install.packages(\"devtools\") devtools::install_github(\"parmsam/forgot\")"},{"path":"https://parmsam.github.io/forgot/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Function Reference Search In Console","text":"examples show solve common problems: Create forgot tibble columns doc sections package functions Search keyword interest forgot tibble search keyword interest specific fields want search across multiple packages, ’s example can use purrr help Lastly, ’s can get reactable HTML table can search ","code":"library(forgot) library(dplyr) ## basic example code functions_in_pkg <- forgot(\"stringr\") functions_in_pkg %>%    select(function_name, title, desc) %>%   head() #> # A tibble: 6 × 3 #>   function_name title                                                      desc  #>   <chr>         <chr>                                                      <chr> #> 1 case          Convert string to upper case, lower case, title case, or … \"\\n\\… #> 2 invert_match  Switch location of matches to location of non-matches      \"\\nI… #> 3 modifiers     Control matching behaviour with modifier functions         \"\\nM… #> 4 %>%           Pipe operator                                              \"\\nP… #> 5 str_c         Join multiple strings into one string                      \"\\n\\… #> 6 str_conv      Specify the encoding of a string                           \"\\nT… forgot(\"stringr\", keyword = \"count\") #> # A tibble: 5 × 13 #>   function_name title     usage desc  value author examples name  aliases params #>   <chr>         <chr>     <chr> <chr> <chr> <chr>  <chr>    <chr> <chr>   <chr>  #> 1 modifiers     Control … \"\\nf… \"\\nM… \"\\nA… \"char… \"\\npatt… modi… \"c(\\\"m… \"c(\\\"… #> 2 str_count     Count nu… \"\\ns… \"\\nC… \"\\nA… \"char… \"\\nfrui… str_… \"NULL\"  \"c(\\\"… #> 3 str_interp    String i… \"\\ns… \"\\n\\… \"\\nA… \"\\nSt… \"\\n\\n# … str_… \"NULL\"  \"c(\\\"… #> 4 str_split     Split up… \"\\ns… \"\\nT… \"\\n\\… \"char… \"\\nfrui… str_… \"c(\\\"s… \"c(\\\"… #> 5 word          Extract … \"\\nw… \"\\nE… \"\\nA… \"char… \"\\nsent… word  \"NULL\"  \"c(\\\"… #> # ℹ 3 more variables: keywords <chr>, seealso <chr>, format <chr> forgot(\"stringr\", keyword = \"count\", selected = c(\"title\", \"desc\")) #> # A tibble: 1 × 3 #>   function_name title                   desc                                     #>   <chr>         <chr>                   <chr>                                    #> 1 str_count     Count number of matches \"\\nCounts the number of times \\\\code{pa… library(purrr) c(\"stringr\", \"dplyr\") %>%   purrr::set_names() %>%   map(forgot, keyword = \"count\") %>%   list_rbind(names_to = \"Package\") forgot(\"stringr\", keyword = \"count\", selected = c(\"title\", \"desc\"),                interactive = T)"},{"path":"https://parmsam.github.io/forgot/index.html","id":"cat-a-roxygen2-field-of-interest-into-your-r-console","dir":"","previous_headings":"Examples","what":"Cat a roxygen2 field of interest into your R console","title":"Function Reference Search In Console","text":"’s can cat (?cat() info) parameter field, usage field, example field. Try see looks. write logical (see forgot_exmpls() documentation example) argument create new RStudio document roxygen2 field content interest cat.","code":"forgot_params(\"dplyr\", \"count\") forgot_usage(\"dplyr\", \"count\") forgot_exmpls(\"dplyr\", \"count\")"},{"path":"https://parmsam.github.io/forgot/index.html","id":"credits","dir":"","previous_headings":"","what":"Credits","title":"Function Reference Search In Console","text":"Hex icon created using hexmake app ColinFay. Confusion icons created Freepik - Flaticon","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve tibble with function documentation for a specified package — forgot","title":"Retrieve tibble with function documentation for a specified package — forgot","text":"Retrieve tibble function documentation specified package","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve tibble with function documentation for a specified package — forgot","text":"","code":"forgot(pkg, keyword = NULL, selected = NULL, formatted = T, interactive = F)"},{"path":"https://parmsam.github.io/forgot/reference/forgot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve tibble with function documentation for a specified package — forgot","text":"pkg string installed R package name keyword optional string filter dataframe mention selected optional string vector columns search , null default formatted boolean coerce columns char, true default interactive optional boolean get reactable HTML table","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve tibble with function documentation for a specified package — forgot","text":"tibble function documentation info","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve tibble with function documentation for a specified package — forgot","text":"","code":"forgot::forgot(\"stringr\") #> # A tibble: 37 × 13 #>    function_name title    usage desc  value author examples name  aliases params #>    <chr>         <chr>    <chr> <chr> <chr> <chr>  <chr>    <chr> <chr>   <chr>  #>  1 case          Convert… \"\\ns… \"\\n\\… \"\\nA… chara… \"\\ndog … case  \"c(\\\"c… \"c(\\\"… #>  2 invert_match  Switch … \"\\ni… \"\\nI… \"\\nn… chara… \"\\nnumb… inve… \"NULL\"  \"loc … #>  3 modifiers     Control… \"\\nf… \"\\nM… \"\\nA… chara… \"\\npatt… modi… \"c(\\\"m… \"c(\\\"… #>  4 %>%           Pipe op… \"\\nl… \"\\nP… \"NUL… chara… \"NULL\"   %>%   \"NULL\"  \"NULL\" #>  5 str_c         Join mu… \"\\ns… \"\\n\\… \"\\nI… chara… \"\\nstr_… str_c \"NULL\"  \"c(\\\"… #>  6 str_conv      Specify… \"\\ns… \"\\nT… \"NUL… chara… \"\\n# Ex… str_… \"NULL\"  \"c(\\\"… #>  7 str_count     Count n… \"\\ns… \"\\nC… \"\\nA… chara… \"\\nfrui… str_… \"NULL\"  \"c(\\\"… #>  8 str_detect    Detect … \"\\ns… \"\\n\\… \"\\nA… chara… \"\\nfrui… str_… \"NULL\"  \"c(\\\"… #>  9 str_dup       Duplica… \"\\ns… \"\\n\\… \"\\nA… chara… \"\\nfrui… str_… \"NULL\"  \"c(\\\"… #> 10 str_equal     Determi… \"\\ns… \"\\nT… \"\\nA… chara… \"\\n# Th… str_… \"NULL\"  \"c(\\\"… #> # ℹ 27 more rows #> # ℹ 3 more variables: keywords <chr>, seealso <chr>, format <chr> forgot::forgot(\"dplyr\", \"count\") #> # A tibble: 11 × 15 #>    function_name title   usage desc  section value author seealso examples name  #>    <chr>         <chr>   <chr> <chr> <chr>   <chr> <chr>  <chr>   <chr>    <chr> #>  1 count         \"Count… \"\\nc… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\n# co… count #>  2 distinct_all  \"Selec… \"\\nd… \"\\n\\… \"Group… \"NUL… chara… \"NULL\"  \"\\ndf <… dist… #>  3 dplyr_by      \"Per-o… \"NUL… \"\\nT… \"NULL\"  \"NUL… chara… \"NULL\"  \"NULL\"   dply… #>  4 filter_all    \"Filte… \"\\nf… \"\\n\\… \"Group… \"NUL… chara… \"NULL\"  \"\\n# Wh… filt… #>  5 if_else       \"Vecto… \"\\ni… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\nx <-… if_e… #>  6 n_distinct    \"Count… \"\\nn… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\nx <-… n_di… #>  7 percent_rank  \"Propo… \"\\np… \"\\nT… \"NULL\"  \"\\nA… chara… \"\\nOth… \"\\nx <-… perc… #>  8 pick          \"Selec… \"\\np… \"\\n\\… \"NULL\"  \"\\nA… chara… \"\\n\\\\c… \"\\ndf <… pick  #>  9 pull          \"Extra… \"\\np… \"\\n\\… \"Metho… \"\\nA… chara… \"NULL\"  \"\\nmtca… pull  #> 10 se-deprecated \"Depre… \"\\na… \"\\n\\… \"NULL\"  \"NUL… chara… \"NULL\"  \"NULL\"   se-d… #> 11 summarise     \"Summa… \"\\ns… \"\\n\\… \"Usefu… \"\\nA… chara… \"\\nOth… \"\\n# A … summ… #> # ℹ 5 more variables: aliases <chr>, params <chr>, keywords <chr>, #> #   details <chr>, format <chr> forgot::forgot(dplyr, \"count\") #> # A tibble: 11 × 15 #>    function_name title   usage desc  section value author seealso examples name  #>    <chr>         <chr>   <chr> <chr> <chr>   <chr> <chr>  <chr>   <chr>    <chr> #>  1 count         \"Count… \"\\nc… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\n# co… count #>  2 distinct_all  \"Selec… \"\\nd… \"\\n\\… \"Group… \"NUL… chara… \"NULL\"  \"\\ndf <… dist… #>  3 dplyr_by      \"Per-o… \"NUL… \"\\nT… \"NULL\"  \"NUL… chara… \"NULL\"  \"NULL\"   dply… #>  4 filter_all    \"Filte… \"\\nf… \"\\n\\… \"Group… \"NUL… chara… \"NULL\"  \"\\n# Wh… filt… #>  5 if_else       \"Vecto… \"\\ni… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\nx <-… if_e… #>  6 n_distinct    \"Count… \"\\nn… \"\\n\\… \"NULL\"  \"\\nA… chara… \"NULL\"  \"\\nx <-… n_di… #>  7 percent_rank  \"Propo… \"\\np… \"\\nT… \"NULL\"  \"\\nA… chara… \"\\nOth… \"\\nx <-… perc… #>  8 pick          \"Selec… \"\\np… \"\\n\\… \"NULL\"  \"\\nA… chara… \"\\n\\\\c… \"\\ndf <… pick  #>  9 pull          \"Extra… \"\\np… \"\\n\\… \"Metho… \"\\nA… chara… \"NULL\"  \"\\nmtca… pull  #> 10 se-deprecated \"Depre… \"\\na… \"\\n\\… \"NULL\"  \"NUL… chara… \"NULL\"  \"NULL\"   se-d… #> 11 summarise     \"Summa… \"\\ns… \"\\n\\… \"Usefu… \"\\nA… chara… \"\\nOth… \"\\n# A … summ… #> # ℹ 5 more variables: aliases <chr>, params <chr>, keywords <chr>, #> #   details <chr>, format <chr>"},{"path":"https://parmsam.github.io/forgot/reference/forgot2.html","id":null,"dir":"Reference","previous_headings":"","what":"Get forgot tibble with only first two fields populated by default — forgot2","title":"Get forgot tibble with only first two fields populated by default — forgot2","text":"Get forgot tibble first two fields populated default","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get forgot tibble with only first two fields populated by default — forgot2","text":"","code":"forgot2(pkg, keyword = NULL, selected = c())"},{"path":"https://parmsam.github.io/forgot/reference/forgot2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get forgot tibble with only first two fields populated by default — forgot2","text":"pkg string installed R package name keyword optional string filter dataframe mention selected optional string vector columns add search","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get forgot tibble with only first two fields populated by default — forgot2","text":"tibble function documentation info","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get forgot tibble with only first two fields populated by default — forgot2","text":"","code":"forgot2(\"stringr\") #> # A tibble: 37 × 2 #>    function_name title                                                           #>    <chr>         <chr>                                                           #>  1 case          Convert string to upper case, lower case, title case, or sente… #>  2 invert_match  Switch location of matches to location of non-matches           #>  3 modifiers     Control matching behaviour with modifier functions              #>  4 %>%           Pipe operator                                                   #>  5 str_c         Join multiple strings into one string                           #>  6 str_conv      Specify the encoding of a string                                #>  7 str_count     Count number of matches                                         #>  8 str_detect    Detect the presence/absence of a match                          #>  9 str_dup       Duplicate a string                                              #> 10 str_equal     Determine if two strings are equivalent                         #> # ℹ 27 more rows forgot2(stringr) #> # A tibble: 37 × 2 #>    function_name title                                                           #>    <chr>         <chr>                                                           #>  1 case          Convert string to upper case, lower case, title case, or sente… #>  2 invert_match  Switch location of matches to location of non-matches           #>  3 modifiers     Control matching behaviour with modifier functions              #>  4 %>%           Pipe operator                                                   #>  5 str_c         Join multiple strings into one string                           #>  6 str_conv      Specify the encoding of a string                                #>  7 str_count     Count number of matches                                         #>  8 str_detect    Detect the presence/absence of a match                          #>  9 str_dup       Duplicate a string                                              #> 10 str_equal     Determine if two strings are equivalent                         #> # ℹ 27 more rows forgot2(\"dplyr\", \"count\") #> # A tibble: 2 × 2 #>   function_name title                                #>   <chr>         <chr>                                #> 1 count         Count the observations in each group #> 2 n_distinct    Count unique combinations            forgot2(dplyr, \"count\") #> # A tibble: 2 × 2 #>   function_name title                                #>   <chr>         <chr>                                #> 1 count         Count the observations in each group #> 2 n_distinct    Count unique combinations"},{"path":"https://parmsam.github.io/forgot/reference/forgotAddin.html","id":null,"dir":"Reference","previous_headings":"","what":"Forgot Rstudio Addin to Search Package Documentation — forgotAddin","title":"Forgot Rstudio Addin to Search Package Documentation — forgotAddin","text":"Creates miniUI forgot RStudio Addin","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgotAddin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forgot Rstudio Addin to Search Package Documentation — forgotAddin","text":"","code":"forgotAddin(selected_pkg = NULL)"},{"path":"https://parmsam.github.io/forgot/reference/forgotAddin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forgot Rstudio Addin to Search Package Documentation — forgotAddin","text":"selected_pkg string optional package name search ","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgotAddin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forgot Rstudio Addin to Search Package Documentation — forgotAddin","text":"","code":"if (FALSE) { forgotAddin(\"dplyr\") }"},{"path":"https://parmsam.github.io/forgot/reference/forgot_exmpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Print examples for an R function of interest in console — forgot_exmpls","title":"Print examples for an R function of interest in console — forgot_exmpls","text":"Print examples R function interest console","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_exmpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print examples for an R function of interest in console — forgot_exmpls","text":"","code":"forgot_exmpls(pkg, function_name, write = FALSE)"},{"path":"https://parmsam.github.io/forgot/reference/forgot_exmpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print examples for an R function of interest in console — forgot_exmpls","text":"pkg string installed R package name function_name function name R package write logical write RStudio rmd file, FALSE default","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_exmpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print examples for an R function of interest in console — forgot_exmpls","text":"","code":"forgot_exmpls(\"dplyr\", \"count\") #>  #> # For better printing #> iris <- as_tibble(iris) #>  #> # across() ----------------------------------------------------------------- #> # Different ways to select the same set of columns #> # See <https://tidyselect.r-lib.org/articles/syntax.html> for details #> iris %>% #>   mutate(across(c(Sepal.Length, Sepal.Width), round)) #> iris %>% #>   mutate(across(c(1, 2), round)) #> iris %>% #>   mutate(across(1:Sepal.Width, round)) #> iris %>% #>   mutate(across(where(is.double) & !c(Petal.Length, Petal.Width), round)) #>  #> # Using an external vector of names #> cols <- c(\"Sepal.Length\", \"Petal.Width\") #> iris %>% #>   mutate(across(all_of(cols), round)) #>  #> # If the external vector is named, the output columns will be named according #> # to those names #> names(cols) <- tolower(cols) #> iris %>% #>   mutate(across(all_of(cols), round)) #>  #> # A purrr-style formula #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), ~ mean(.x, na.rm = TRUE))) #>  #> # A named list of functions #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd))) #>  #> # Use the .names argument to control the output names #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), mean, .names = \"mean_{.col}\")) #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd), .names = \"{.col}.{.fn}\")) #>  #> # If a named external vector is used for column selection, .names will use #> # those names when constructing the output names #> iris %>% #>   group_by(Species) %>% #>   summarise(across(all_of(cols), mean, .names = \"mean_{.col}\")) #>  #> # When the list is not named, .fn is replaced by the function's position #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean, sd), .names = \"{.col}.fn{.fn}\")) #>  #> # When the functions in .fns return a data frame, you typically get a #> # \"packed\" data frame back #> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) { #>   tibble(quantile = probs, value = quantile(x, probs)) #> } #>  #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df)) #>  #> # Use .unpack to automatically expand these packed data frames into their #> # individual columns #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df, .unpack = TRUE)) #>  #> # .unpack can utilize a glue specification if you don't like the defaults #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df, .unpack = \"{outer}.{inner}\")) #>  #> # This is also useful inside mutate(), for example, with a multi-lag helper #> multilag <- function(x, lags = 1:3) { #>   names(lags) <- as.character(lags) #>   purrr::map_dfr(lags, lag, x = x) #> } #>  #> iris %>% #>   group_by(Species) %>% #>   mutate(across(starts_with(\"Sepal\"), multilag, .unpack = TRUE)) %>% #>   select(Species, starts_with(\"Sepal\")) #>  #> # if_any() and if_all() ---------------------------------------------------- #> iris %>% #>   filter(if_any(ends_with(\"Width\"), ~ . > 4)) #> iris %>% #>   filter(if_all(ends_with(\"Width\"), ~ . > 2)) #>  #>  NULL  #> scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))] #>  #> # `all_equal()` ignored row and column ordering by default, #> # but we now feel that that makes it too easy to make mistakes #> mtcars2 <- scramble(mtcars) #> all_equal(mtcars, mtcars2) #>  #> # Instead, be explicit about the row and column ordering #> all.equal( #>   mtcars, #>   mtcars2[rownames(mtcars), names(mtcars)] #> ) #>  NULL NULL  #> arrange(mtcars, cyl, disp) #> arrange(mtcars, desc(disp)) #>  #> # grouped arrange ignores groups #> by_cyl <- mtcars %>% group_by(cyl) #> by_cyl %>% arrange(desc(wt)) #> # Unless you specifically ask: #> by_cyl %>% arrange(desc(wt), .by_group = TRUE) #>  #> # use embracing when wrapping in a function; #> # see ?rlang::args_data_masking for more details #> tidy_eval_arrange <- function(.data, var) { #>   .data %>% #>     arrange({{ var }}) #> } #> tidy_eval_arrange(mtcars, mpg) #>  #> # Use `across()` or `pick()` to select columns with tidy-select #> iris %>% arrange(pick(starts_with(\"Sepal\"))) #> iris %>% arrange(across(starts_with(\"Sepal\"), desc)) #>   #> df <- as_tibble(mtcars) #> arrange_all(df) #> # -> #> arrange(df, pick(everything())) #>  #> arrange_all(df, desc) #> # -> #> arrange(df, across(everything(), desc)) #>  NULL NULL  #> band_members #> band_instruments #> band_instruments2 #>   #> between(1:12, 7, 9) #>  #> x <- rnorm(1e2) #> x[between(x, -1, 1)] #>  #> # On a tibble using `filter()` #> filter(starwars, between(height, 100, 150)) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(y = 3:1) #> bind_cols(df1, df2) #>  #> # Row sizes must be compatible when column-binding #> try(bind_cols(tibble(x = 1:3), tibble(y = 1:2))) #>   #> df1 <- tibble(x = 1:2, y = letters[1:2]) #> df2 <- tibble(x = 4:5, z = 1:2) #>  #> # You can supply individual data frames as arguments: #> bind_rows(df1, df2) #>  #> # Or a list of data frames: #> bind_rows(list(df1, df2)) #>  #> # When you supply a column name with the `.id` argument, a new #> # column is created to link each row to its original data frame #> bind_rows(list(df1, df2), .id = \"id\") #> bind_rows(list(a = df1, b = df2), .id = \"id\") #>   #> df <- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4)) #> df %>% #>   rowwise() %>% #>   mutate( #>     sum = sum(c_across(w:z)), #>     sd = sd(c_across(w:z)) #>   ) #>   #> x <- c(\"a\", \"b\", \"a\", \"d\", \"b\", NA, \"c\", \"e\") #>  #> # `case_match()` acts like a vectorized `switch()`. #> # Unmatched values \"fall through\" as a missing value. #> case_match( #>   x, #>   \"a\" ~ 1, #>   \"b\" ~ 2, #>   \"c\" ~ 3, #>   \"d\" ~ 4 #> ) #>  #> # Missing values can be matched exactly, and `.default` can be used to #> # control the value used for unmatched values of `.x` #> case_match( #>   x, #>   \"a\" ~ 1, #>   \"b\" ~ 2, #>   \"c\" ~ 3, #>   \"d\" ~ 4, #>   NA ~ 0, #>   .default = 100 #> ) #>  #> # Input values can be grouped into the same expression to map them to the #> # same output value #> case_match( #>   x, #>   c(\"a\", \"b\") ~ \"low\", #>   c(\"c\", \"d\", \"e\") ~ \"high\" #> ) #>  #> # `case_match()` isn't limited to character input: #> y <- c(1, 2, 1, 3, 1, NA, 2, 4) #>  #> case_match( #>   y, #>   c(1, 3) ~ \"odd\", #>   c(2, 4) ~ \"even\", #>   .default = \"missing\" #> ) #>  #> # Setting `.default` to the original vector is a useful way to replace #> # selected values, leaving everything else as is #> case_match(y, NA ~ 0, .default = y) #>  #> starwars %>% #>   mutate( #>     # Replace missings, but leave everything else alone #>     hair_color = case_match(hair_color, NA ~ \"unknown\", .default = hair_color), #>     # Replace some, but not all, of the species #>     species = case_match( #>       species, #>       \"Human\" ~ \"Humanoid\", #>       \"Droid\" ~ \"Robot\", #>       c(\"Wookiee\", \"Ewok\") ~ \"Hairy\", #>       .default = species #>     ), #>     .keep = \"used\" #>   ) #>   #> x <- 1:70 #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #>   .default = as.character(x) #> ) #>  #> # Like an if statement, the arguments are evaluated in order, so you must #> # proceed from the most specific to the most general. This won't work: #> case_when( #>   x %%  5 == 0 ~ \"fizz\", #>   x %%  7 == 0 ~ \"buzz\", #>   x %% 35 == 0 ~ \"fizz buzz\", #>   .default = as.character(x) #> ) #>  #> # If none of the cases match and no `.default` is supplied, NA is used: #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #> ) #>  #> # Note that `NA` values on the LHS are treated like `FALSE` and will be #> # assigned the `.default` value. You must handle them explicitly if you #> # want to use a different value. The exact way to handle missing values is #> # dependent on the set of LHS conditions you use. #> x[2:4] <- NA_real_ #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #>   is.na(x) ~ \"nope\", #>   .default = as.character(x) #> ) #>  #> # `case_when()` evaluates all RHS expressions, and then constructs its #> # result by extracting the selected (via the LHS expressions) parts. #> # In particular `NaN`s are produced in this case: #> y <- seq(-2, 2, by = .5) #> case_when( #>   y >= 0 ~ sqrt(y), #>   .default = y #> ) #>  #> # `case_when()` is particularly useful inside `mutate()` when you want to #> # create a new variable that relies on a complex combination of existing #> # variables #> starwars %>% #>   select(name:mass, gender, species) %>% #>   mutate( #>     type = case_when( #>       height > 200 | mass > 200 ~ \"large\", #>       species == \"Droid\" ~ \"robot\", #>       .default = \"other\" #>     ) #>   ) #>  #>  #> # `case_when()` is not a tidy eval function. If you'd like to reuse #> # the same patterns, extract the `case_when()` call in a normal #> # function: #> case_character_type <- function(height, mass, species) { #>   case_when( #>     height > 200 | mass > 200 ~ \"large\", #>     species == \"Droid\" ~ \"robot\", #>     .default = \"other\" #>   ) #> } #>  #> case_character_type(150, 250, \"Droid\") #> case_character_type(150, 150, \"Droid\") #>  #> # Such functions can be used inside `mutate()` as well: #> starwars %>% #>   mutate(type = case_character_type(height, mass, species)) %>% #>   pull(type) #>  #> # `case_when()` ignores `NULL` inputs. This is useful when you'd #> # like to use a pattern only under certain conditions. Here we'll #> # take advantage of the fact that `if` returns `NULL` when there is #> # no `else` clause: #> case_character_type <- function(height, mass, species, robots = TRUE) { #>   case_when( #>     height > 200 | mass > 200 ~ \"large\", #>     if (robots) species == \"Droid\" ~ \"robot\", #>     .default = \"other\" #>   ) #> } #>  #> starwars %>% #>   mutate(type = case_character_type(height, mass, species, robots = FALSE)) %>% #>   pull(type) #>   #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> wrap_dbplyr_obj(\"build_sql\") #> wrap_dbplyr_obj(\"base_agg\") #> \\dontshow{}) # examplesIf} #>   #> # Use a single value to replace all missing values #> x <- sample(c(1:5, NA, NA, NA)) #> coalesce(x, 0L) #>  #> # The equivalent to a missing value in a list is `NULL` #> coalesce(list(1, 2, NULL), list(NA)) #>  #> # Or generate a complete vector from partially missing pieces #> y <- c(1, 2, NA, NA, 5) #> z <- c(NA, NA, 3, 4, 5) #> coalesce(y, z) #>  #> # Supply lists by splicing them into dots: #> vecs <- list( #>   c(1, 2, NA, NA, 5), #>   c(NA, NA, 3, 4, 5) #> ) #> coalesce(!!!vecs) #>   #> f1 <- factor(\"a\") #> f2 <- factor(\"b\") #>  #> combine(f1, f2) #> # -> #> vctrs::vec_c(f1, f1) #>  #> combine(list(f1, f2)) #> # -> #> vctrs::vec_c(!!!list(f1, f2)) #>  NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> mtcars2 <- dbplyr::src_memdb() %>% #>   copy_to(mtcars, name = \"mtcars2-cc\", overwrite = TRUE) #>  #> remote <- mtcars2 %>% #>   filter(cyl == 8) %>% #>   select(mpg:drat) #>  #> # Compute query and save in remote table #> compute(remote) #>  #> # Compute query bring back to this session #> collect(remote) #>  #> # Creates a fresh query based on the generated SQL #> collapse(remote) #> \\dontshow{}) # examplesIf} #>   #> consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA)) #> consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2)) #>  #> df <- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2)) #> df %>% group_by(x, y) %>% summarise(n = n()) #> df %>% group_by(id = consecutive_id(x, y), x, y) %>% summarise(n = n()) #>   #> df <- tibble( #>   g = sample(rep(letters[1:3], 1:3)), #>   x = runif(6), #>   y = runif(6) #> ) #> gf <- df %>% group_by(g) #>  #> gf %>% summarise(n = n()) #>  #> gf %>% mutate(id = cur_group_id()) #> gf %>% reframe(row = cur_group_rows()) #> gf %>% summarise(data = list(cur_group())) #>  #> gf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2)))) #>   #> \\dontrun{ #> iris2 <- dbplyr::src_memdb() %>% copy_to(iris, overwrite = TRUE) #> iris2 #> } #>   #> # count() is a convenient way to get a sense of the distribution of #> # values in a dataset #> starwars %>% count(species) #> starwars %>% count(species, sort = TRUE) #> starwars %>% count(sex, gender, sort = TRUE) #> starwars %>% count(birth_decade = round(birth_year, -1)) #>  #> # use the `wt` argument to perform a weighted count. This is useful #> # when the data has already been aggregated once #> df <- tribble( #>   ~name,    ~gender,   ~runs, #>   \"Max\",    \"male\",       10, #>   \"Sandra\", \"female\",      1, #>   \"Susan\",  \"female\",      4 #> ) #> # counts rows: #> df %>% count(gender) #> # counts runs: #> df %>% count(gender, wt = runs) #>  #> # When factors are involved, `.drop = FALSE` can be used to retain factor #> # levels that don't appear in the data #> df2 <- tibble( #>   id = 1:5, #>   type = factor(c(\"a\", \"c\", \"a\", NA, \"a\"), levels = c(\"a\", \"b\", \"c\")) #> ) #> df2 %>% count(type) #> df2 %>% count(type, .drop = FALSE) #>  #> # Or, using `group_by()`: #> df2 %>% group_by(type, .drop = FALSE) %>% count() #>  #> # tally() is a lower-level function that assumes you've done the grouping #> starwars %>% tally() #> starwars %>% group_by(species) %>% tally() #>  #> # both count() and tally() have add_ variants that work like #> # mutate() instead of summarise #> df %>% add_count(gender, wt = runs) #> df %>% add_tally(wt = runs) #>   #> # Cross joins match each row in `x` to every row in `y`. #> # Data within the columns is not used in the matching process. #> cross_join(band_instruments, band_members) #>  #> # Control the suffix added to variables duplicated in #> # `x` and `y` with `suffix`. #> cross_join(band_instruments, band_members, suffix = c(\"\", \"_y\")) #>   #> # `cummean()` returns a numeric/integer vector of the same length #> # as the input vector. #> x <- c(1, 3, 5, 2, 2) #> cummean(x) #> cumsum(x) / seq_along(x) #>  #> # `cumall()` and `cumany()` return logicals #> cumall(x < 5) #> cumany(x == 3) #>  #> # `cumall()` vs. `cumany()` #> df <- data.frame( #>   date = as.Date(\"2020-01-01\") + 0:6, #>   balance = c(100, 50, 25, -25, -50, 30, 120) #> ) #> # all rows after first overdraft #> df %>% filter(cumany(balance < 0)) #> # all rows until first overdraft #> df %>% filter(cumall(!(balance < 0))) #>  #>  NULL NULL  #> desc(1:10) #> desc(factor(letters)) #>  #> first_day <- seq(as.Date(\"1910/1/1\"), as.Date(\"1920/1/1\"), \"years\") #> desc(first_day) #>  #> starwars %>% arrange(desc(mass)) #>   #> dim_desc(mtcars) #>   #> df <- tibble( #>   x = sample(10, 100, rep = TRUE), #>   y = sample(10, 100, rep = TRUE) #> ) #> nrow(df) #> nrow(distinct(df)) #> nrow(distinct(df, x, y)) #>  #> distinct(df, x) #> distinct(df, y) #>  #> # You can choose to keep all other variables as well #> distinct(df, x, .keep_all = TRUE) #> distinct(df, y, .keep_all = TRUE) #>  #> # You can also use distinct on computed variables #> distinct(df, diff = abs(x - y)) #>  #> # Use `pick()` to select columns with tidy-select #> distinct(starwars, pick(contains(\"color\"))) #>  #> # Grouping ------------------------------------------------- #>  #> df <- tibble( #>   g = c(1, 1, 2, 2, 2), #>   x = c(1, 1, 2, 1, 2), #>   y = c(3, 2, 1, 3, 1) #> ) #> df <- df %>% group_by(g) #>  #> # With grouped data frames, distinctness is computed within each group #> df %>% distinct(x) #>  #> # When `...` are omitted, `distinct()` still computes distinctness using #> # all variables in the data frame #> df %>% distinct() #>   #> df <- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2) #>  #> distinct_all(df) #> # -> #> distinct(df, pick(everything())) #>  #> distinct_at(df, vars(x,y)) #> # -> #> distinct(df, pick(x, y)) #>  #> distinct_if(df, is.numeric) #> # -> #> distinct(df, pick(where(is.numeric))) #>  #> # You can supply a function that will be applied before extracting the distinct values #> # The variables of the sorted tibble keep their original values. #> distinct_all(df, round) #> # -> #> distinct(df, across(everything(), round)) #>   #> # do() with unnamed arguments becomes reframe() or summarise() #> # . becomes pick() #> by_cyl <- mtcars %>% group_by(cyl) #> by_cyl %>% do(head(., 2)) #> # -> #> by_cyl %>% reframe(head(pick(everything()), 2)) #> by_cyl %>% slice_head(n = 2) #>  #> # Can refer to variables directly #> by_cyl %>% do(mean = mean(.$vs)) #> # -> #> by_cyl %>% summarise(mean = mean(vs)) #>  #> # do() with named arguments becomes nest_by() + mutate() & list() #> models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .)) #> # -> #> models <- mtcars %>% #>   nest_by(cyl) %>% #>   mutate(mod = list(lm(mpg ~ disp, data = data))) #> models %>% summarise(rsq = summary(mod)$r.squared) #>  #> # use broom to turn models into data #> models %>% do(data.frame( #>   var = names(coef(.$mod)), #>   coef(summary(.$mod))) #> ) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> # -> #> models %>% reframe(broom::tidy(mod)) #> \\dontshow{}) # examplesIf} #>   #> \\dontshow{if (dplyr:::has_minimum_stringi()) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> df <- tibble(x = c(\"a\", \"b\", \"C\", \"B\", \"c\")) #> df #>  #> # Default locale is C, which groups the English alphabet by case, placing #> # uppercase letters before lowercase letters. #> arrange(df, x) #>  #> # The American English locale groups the alphabet by letter. #> # Explicitly override `.locale` with `\"en\"` for this ordering. #> arrange(df, x, .locale = \"en\") #>  #> # This Danish letter is expected to sort after `z` #> df <- tibble(x = c(\"o\", \"p\", \"\\u00F8\", \"z\")) #> df #>  #> # The American English locale sorts it right after `o` #> arrange(df, x, .locale = \"en\") #>  #> # Using `\"da\"` for Danish ordering gives the expected result #> arrange(df, x, .locale = \"da\") #>  #> # If you need the legacy behavior of `arrange()`, which respected the #> # system locale, then you can set the global option `dplyr.legacy_locale`, #> # but expect this to be removed in the future. We recommend that you use #> # the `.locale` argument instead. #> rlang::with_options(dplyr.legacy_locale = TRUE, { #>   arrange(df, x) #> }) #> \\dontshow{}) # examplesIf} #>  NULL NULL NULL NULL NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> \\donttest{ #> lahman_s <- dbplyr::lahman_sqlite() #> batting <- tbl(lahman_s, \"Batting\") #> batting %>% show_query() #> batting %>% explain() #>  #> # The batting database has indices on all ID variables: #> # SQLite automatically picks the most restrictive index #> batting %>% filter(lgID == \"NL\" & yearID == 2000L) %>% explain() #>  #> # OR's will use multiple indexes #> batting %>% filter(lgID == \"NL\" | yearID == 2000) %>% explain() #>  #> # Joins will use indexes in both tables #> teams <- tbl(lahman_s, \"Teams\") #> batting %>% left_join(teams, c(\"yearID\", \"teamID\")) %>% explain() #> } #> \\dontshow{}) # examplesIf} #>   #> # \"Filtering\" joins keep cases from the LHS #> band_members %>% semi_join(band_instruments) #> band_members %>% anti_join(band_instruments) #>  #> # To suppress the message about joining variables, supply `by` #> band_members %>% semi_join(band_instruments, by = join_by(name)) #> # This is good practice in production code #>   #> # Filtering by one criterion #> filter(starwars, species == \"Human\") #> filter(starwars, mass > 1000) #>  #> # Filtering by multiple criteria within a single logical expression #> filter(starwars, hair_color == \"none\" & eye_color == \"black\") #> filter(starwars, hair_color == \"none\" | eye_color == \"black\") #>  #> # When multiple expressions are used, they are combined using & #> filter(starwars, hair_color == \"none\", eye_color == \"black\") #>  #>  #> # The filtering operation may yield different results on grouped #> # tibbles because the expressions are computed within groups. #> # #> # The following filters rows where `mass` is greater than the #> # global average: #> starwars %>% filter(mass > mean(mass, na.rm = TRUE)) #>  #> # Whereas this keeps rows with `mass` greater than the gender #> # average: #> starwars %>% group_by(gender) %>% filter(mass > mean(mass, na.rm = TRUE)) #>  #>  #> # To refer to column names that are stored as strings, use the `.data` pronoun: #> vars <- c(\"mass\", \"height\") #> cond <- c(80, 150) #> starwars %>% #>   filter( #>     .data[[vars[[1]]]] > cond[[1]], #>     .data[[vars[[2]]]] > cond[[2]] #>   ) #> # Learn more in ?rlang::args_data_masking #>   #> # While filter() accepts expressions with specific variables, the #> # scoped filter verbs take an expression with the pronoun `.` and #> # replicate it over all variables. This expression should be quoted #> # with all_vars() or any_vars(): #> all_vars(is.na(.)) #> any_vars(is.na(.)) #>  #>  #> # You can take the intersection of the replicated expressions: #> filter_all(mtcars, all_vars(. > 150)) #> # -> #> filter(mtcars, if_all(everything(), ~ .x > 150)) #>  #> # Or the union: #> filter_all(mtcars, any_vars(. > 150)) #> # -> #> filter(mtcars, if_any(everything(), ~ . > 150)) #>  #>  #> # You can vary the selection of columns on which to apply the #> # predicate. filter_at() takes a vars() specification: #> filter_at(mtcars, vars(starts_with(\"d\")), any_vars((. %% 2) == 0)) #> # -> #> filter(mtcars, if_any(starts_with(\"d\"), ~ (.x %% 2) == 0)) #>  #> # And filter_if() selects variables with a predicate function: #> filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0)) #> # -> #> is_int <- function(x) all(floor(x) == x) #> filter(mtcars, if_all(where(is_int), ~ .x != 0)) #>   #> funs(\"mean\", mean(., na.rm = TRUE)) #> # -> #> list(mean = mean, mean = ~ mean(.x, na.rm = TRUE)) #>  #> funs(m1 = mean, m2 = \"mean\", m3 = mean(., na.rm = TRUE)) #> # -> #> list(m1 = mean, m2 = \"mean\", m3 = ~ mean(.x, na.rm = TRUE)) #>   #> glimpse(mtcars) #>  #> # Note that original x is (invisibly) returned, allowing `glimpse()` to be #> # used within a pipeline. #> mtcars %>% #>   glimpse() %>% #>   select(1:3) #>  #> glimpse(starwars) #>   #> by_cyl <- mtcars %>% group_by(cyl) #>  #> # grouping doesn't change how the data looks (apart from listing #> # how it's grouped): #> by_cyl #>  #> # It changes how it acts with the other dplyr verbs: #> by_cyl %>% summarise( #>   disp = mean(disp), #>   hp = mean(hp) #> ) #> by_cyl %>% filter(disp == max(disp)) #>  #> # Each call to summarise() removes a layer of grouping #> by_vs_am <- mtcars %>% group_by(vs, am) #> by_vs <- by_vs_am %>% summarise(n = n()) #> by_vs #> by_vs %>% summarise(n = sum(n)) #>  #> # To removing grouping, use ungroup #> by_vs %>% #>   ungroup() %>% #>   summarise(n = sum(n)) #>  #> # By default, group_by() overrides existing grouping #> by_cyl %>% #>   group_by(vs, am) %>% #>   group_vars() #>  #> # Use add = TRUE to instead append #> by_cyl %>% #>   group_by(vs, am, .add = TRUE) %>% #>   group_vars() #>  #> # You can group by expressions: this is a short-hand #> # for a mutate() followed by a group_by() #> mtcars %>% #>   group_by(vsam = vs + am) #>  #> # The implicit mutate() step is always performed on the #> # ungrouped data. Here we get 3 groups: #> mtcars %>% #>   group_by(vs) %>% #>   group_by(hp_cut = cut(hp, 3)) #>  #> # If you want it to be performed by groups, #> # you have to use an explicit mutate() call. #> # Here we get 3 groups per value of vs #> mtcars %>% #>   group_by(vs) %>% #>   mutate(hp_cut = cut(hp, 3)) %>% #>   group_by(hp_cut) #>  #> # when factors are involved and .drop = FALSE, groups can be empty #> tbl <- tibble( #>   x = 1:10, #>   y = factor(rep(c(\"a\", \"c\"), each  = 5), levels = c(\"a\", \"b\", \"c\")) #> ) #> tbl %>% #>   group_by(y, .drop = FALSE) %>% #>   group_rows() #>  #>   #> # Group a data frame by all variables: #> group_by_all(mtcars) #> # -> #> mtcars %>% group_by(pick(everything())) #>  #> # Group by variables selected with a predicate: #> group_by_if(iris, is.factor) #> # -> #> iris %>% group_by(pick(where(is.factor))) #>  #> # Group by variables selected by name: #> group_by_at(mtcars, vars(vs, am)) #> # -> #> mtcars %>% group_by(pick(vs, am)) #>  #> # Like group_by(), the scoped variants have optional mutate #> # semantics. This provide a shortcut for group_by() + mutate(): #> d <- tibble(x=c(1,1,2,2), y=c(1,2,1,2)) #> group_by_all(d, as.factor) #> # -> #> d %>% group_by(across(everything(), as.factor)) #>  #> group_by_if(iris, is.factor, as.character) #> # -> #> iris %>% group_by(across(where(is.factor), as.character)) #>   #> group_by_drop_default(iris) #>  #> iris %>% #>   group_by(Species) %>% #>   group_by_drop_default() #>  #> iris %>% #>   group_by(Species, .drop = FALSE) %>% #>   group_by_drop_default() #>  #>  NULL  #> gdf <- iris %>% group_by(Species) #> gdf %>% select(group_cols()) #>  #> # Remove the grouping variables from mutate selections: #> gdf %>% mutate_at(vars(-group_cols()), `/`, 100) #> # -> No longer necessary with across() #> gdf %>% mutate(across(everything(), ~ . / 100)) #>   #> df <- tibble(x = c(1,1,2,2)) #> group_vars(df) #> group_rows(df) #> group_data(df) #> group_indices(df) #>  #> gf <- group_by(df, x) #> group_vars(gf) #> group_rows(gf) #> group_data(gf) #> group_indices(gf) #>   #>  #> # return a list #> mtcars %>% #>   group_by(cyl) %>% #>   group_map(~ head(.x, 2L)) #>  #> # return a tibble grouped by `cyl` with 2 rows per group #> # the grouping data is recalculated #> mtcars %>% #>   group_by(cyl) %>% #>   group_modify(~ head(.x, 2L)) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # a list of tibbles #> iris %>% #>   group_by(Species) %>% #>   group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) #>  #> # a restructured grouped tibble #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) #> \\dontshow{}) # examplesIf} #>  #> # a list of vectors #> iris %>% #>   group_by(Species) %>% #>   group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75))) #>  #> # to use group_modify() the lambda must return a data frame #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ { #>      quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %>% #>      tibble::enframe(name = \"prob\", value = \"quantile\") #>   }) #>  #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ { #>     .x %>% #>       purrr::map_dfc(fivenum) %>% #>       mutate(nms = c(\"min\", \"Q1\", \"median\", \"Q3\", \"max\")) #>   }) #>  #> # group_walk() is for side effects #> dir.create(temp <- tempfile()) #> iris %>% #>   group_by(Species) %>% #>   group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, \".csv\")))) #> list.files(temp, pattern = \"csv$\") #> unlink(temp, recursive = TRUE) #>  #> # group_modify() and ungrouped data frames #> mtcars %>% #>   group_modify(~ head(.x, 2L)) #>  #>   #>  #> #----- use case 1: a grouped data frame #> iris %>% #>   group_by(Species) %>% #>   group_nest() #>  #> # this can be useful if the grouped data has been altered before nesting #> iris %>% #>   group_by(Species) %>% #>   filter(Sepal.Length > mean(Sepal.Length)) %>% #>   group_nest() #>  #> #----- use case 2: using group_nest() on a ungrouped data frame with #> #                  a grouping specification that uses the data mask #> starwars %>% #>   group_nest(species, homeworld) #>   #> ir <- iris %>% group_by(Species) #>  #> group_split(ir) #> group_keys(ir) #>   #> iris %>% #>   group_by(Species) %>% #>   filter(Species == \"setosa\", .preserve = TRUE) %>% #>   group_trim() #>  NULL  #> # Identifiers are escaped with \" #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> ident(\"x\") #> \\dontshow{}) # examplesIf} #>   #> x <- c(-5:5, NA) #> if_else(x < 0, NA, x) #>  #> # Explicitly handle `NA` values in the `condition` with `missing` #> if_else(x < 0, \"negative\", \"positive\", missing = \"missing\") #>  #> # Unlike `ifelse()`, `if_else()` preserves types #> x <- factor(sample(letters[1:5], 10, replace = TRUE)) #> ifelse(x %in% c(\"a\", \"b\", \"c\"), x, NA) #> if_else(x %in% c(\"a\", \"b\", \"c\"), x, NA) #>  #> # `if_else()` is often useful for creating new columns inside of `mutate()` #> starwars %>% #>   mutate(category = if_else(height < 100, \"short\", \"tall\"), .keep = \"used\") #>   #> sales <- tibble( #>   id = c(1L, 1L, 1L, 2L, 2L), #>   sale_date = as.Date(c(\"2018-12-31\", \"2019-01-02\", \"2019-01-05\", \"2019-01-04\", \"2019-01-01\")) #> ) #> sales #>  #> promos <- tibble( #>   id = c(1L, 1L, 2L), #>   promo_date = as.Date(c(\"2019-01-01\", \"2019-01-05\", \"2019-01-02\")) #> ) #> promos #>  #> # Match `id` to `id`, and `sale_date` to `promo_date` #> by <- join_by(id, sale_date == promo_date) #> left_join(sales, promos, by) #>  #> # For each `sale_date` within a particular `id`, #> # find all `promo_date`s that occurred before that particular sale #> by <- join_by(id, sale_date >= promo_date) #> left_join(sales, promos, by) #>  #> # For each `sale_date` within a particular `id`, #> # find only the closest `promo_date` that occurred before that sale #> by <- join_by(id, closest(sale_date >= promo_date)) #> left_join(sales, promos, by) #>  #> # If you want to disallow exact matching in rolling joins, use `>` rather #> # than `>=`. Note that the promo on `2019-01-05` is no longer considered the #> # closest match for the sale on the same date. #> by <- join_by(id, closest(sale_date > promo_date)) #> left_join(sales, promos, by) #>  #> # Same as before, but also require that the promo had to occur at most 1 #> # day before the sale was made. We'll use a full join to see that id 2's #> # promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`. #> sales <- mutate(sales, sale_date_lower = sale_date - 1) #> by <- join_by(id, closest(sale_date >= promo_date), sale_date_lower <= promo_date) #> full_join(sales, promos, by) #>  #> # --------------------------------------------------------------------------- #>  #> segments <- tibble( #>   segment_id = 1:4, #>   chromosome = c(\"chr1\", \"chr2\", \"chr2\", \"chr1\"), #>   start = c(140, 210, 380, 230), #>   end = c(150, 240, 415, 280) #> ) #> segments #>  #> reference <- tibble( #>   reference_id = 1:4, #>   chromosome = c(\"chr1\", \"chr1\", \"chr2\", \"chr2\"), #>   start = c(100, 200, 300, 415), #>   end = c(150, 250, 399, 450) #> ) #> reference #>  #> # Find every time a segment `start` falls between the reference #> # `[start, end]` range. #> by <- join_by(chromosome, between(start, start, end)) #> full_join(segments, reference, by) #>  #> # If you wanted the reference columns first, supply `reference` as `x` #> # and `segments` as `y`, then explicitly refer to their columns using `x$` #> # and `y$`. #> by <- join_by(chromosome, between(y$start, x$start, x$end)) #> full_join(reference, segments, by) #>  #> # Find every time a segment falls completely within a reference. #> # Sometimes using `x$` and `y$` makes your intentions clearer, even if they #> # match the default behavior. #> by <- join_by(chromosome, within(x$start, x$end, y$start, y$end)) #> inner_join(segments, reference, by) #>  #> # Find every time a segment overlaps a reference in any way. #> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end)) #> full_join(segments, reference, by) #>  #> # It is common to have right-open ranges with bounds like `[)`, which would #> # mean an end value of `415` would no longer overlap a start value of `415`. #> # Setting `bounds` allows you to compute overlaps with those kinds of ranges. #> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = \"[)\")) #> full_join(segments, reference, by) #>  NULL  #> lag(1:5) #> lead(1:5) #>  #> x <- 1:5 #> tibble(behind = lag(x), x, ahead = lead(x)) #>  #> # If you want to look more rows behind or ahead, use `n` #> lag(1:5, n = 1) #> lag(1:5, n = 2) #>  #> lead(1:5, n = 1) #> lead(1:5, n = 2) #>  #> # If you want to define a value to pad with, use `default` #> lag(1:5) #> lag(1:5, default = 0) #>  #> lead(1:5) #> lead(1:5, default = 6) #>  #> # If the data are not already ordered, use `order_by` #> scrambled <- slice_sample( #>   tibble(year = 2000:2005, value = (0:5) ^ 2), #>   prop = 1 #> ) #>  #> wrong <- mutate(scrambled, previous_year_value = lag(value)) #> arrange(wrong, year) #>  #> right <- mutate(scrambled, previous_year_value = lag(value, order_by = year)) #> arrange(right, year) #>  NULL  #> band_members %>% inner_join(band_instruments) #> band_members %>% left_join(band_instruments) #> band_members %>% right_join(band_instruments) #> band_members %>% full_join(band_instruments) #>  #> # To suppress the message about joining variables, supply `by` #> band_members %>% inner_join(band_instruments, by = join_by(name)) #> # This is good practice in production code #>  #> # Use an equality expression if the join variables have different names #> band_members %>% full_join(band_instruments2, by = join_by(name == artist)) #> # By default, the join keys from `x` and `y` are coalesced in the output; use #> # `keep = TRUE` to keep the join keys from both `x` and `y` #> band_members %>% #>   full_join(band_instruments2, by = join_by(name == artist), keep = TRUE) #>  #> # If a row in `x` matches multiple rows in `y`, all the rows in `y` will be #> # returned once for each matching row in `x`. #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = c(1, 1, 2), y = c(\"first\", \"second\", \"third\")) #> df1 %>% left_join(df2) #>  #> # If a row in `y` also matches multiple rows in `x`, this is known as a #> # many-to-many relationship, which is typically a result of an improperly #> # specified join or some kind of messy data. In this case, a warning is #> # thrown by default: #> df3 <- tibble(x = c(1, 1, 1, 3)) #> df3 %>% left_join(df2) #>  #> # In the rare case where a many-to-many relationship is expected, set #> # `relationship = \"many-to-many\"` to silence this warning #> df3 %>% left_join(df2, relationship = \"many-to-many\") #>  #> # Use `join_by()` with a condition other than `==` to perform an inequality #> # join. Here we match on every instance where `df1$x > df2$x`. #> df1 %>% left_join(df2, join_by(x > x)) #>  #> # By default, NAs match other NAs so that there are two #> # rows in the output of this join: #> df1 <- data.frame(x = c(1, NA), y = 2) #> df2 <- data.frame(x = c(1, NA), z = 3) #> left_join(df1, df2) #>  #> # You can optionally request that NAs don't match, giving a #> # a result that more closely resembles SQL joins #> left_join(df1, df2, na_matches = \"never\") #>   #> # Newly created variables are available immediately #> starwars %>% #>   select(name, mass) %>% #>   mutate( #>     mass2 = mass * 2, #>     mass2_squared = mass2 * mass2 #>   ) #>  #> # As well as adding new variables, you can use mutate() to #> # remove variables and modify existing variables. #> starwars %>% #>   select(name, height, mass, homeworld) %>% #>   mutate( #>     mass = NULL, #>     height = height * 0.0328084 # convert to feet #>   ) #>  #> # Use across() with mutate() to apply a transformation #> # to multiple columns in a tibble. #> starwars %>% #>   select(name, homeworld, species) %>% #>   mutate(across(!name, as.factor)) #> # see more in ?across #>  #> # Window functions are useful for grouped mutates: #> starwars %>% #>   select(name, mass, homeworld) %>% #>   group_by(homeworld) %>% #>   mutate(rank = min_rank(desc(mass))) #> # see `vignette(\"window-functions\")` for more details #>  #> # By default, new columns are placed on the far right. #> df <- tibble(x = 1, y = 2) #> df %>% mutate(z = x + y) #> df %>% mutate(z = x + y, .before = 1) #> df %>% mutate(z = x + y, .after = x) #>  #> # By default, mutate() keeps all columns from the input data. #> df <- tibble(x = 1, y = 2, a = \"a\", b = \"b\") #> df %>% mutate(z = x + y, .keep = \"all\") # the default #> df %>% mutate(z = x + y, .keep = \"used\") #> df %>% mutate(z = x + y, .keep = \"unused\") #> df %>% mutate(z = x + y, .keep = \"none\") #>  #> # Grouping ---------------------------------------- #> # The mutate operation may yield different results on grouped #> # tibbles because the expressions are computed within groups. #> # The following normalises `mass` by the global average: #> starwars %>% #>   select(name, mass, species) %>% #>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) #>  #> # Whereas this normalises `mass` by the averages within species #> # levels: #> starwars %>% #>   select(name, mass, species) %>% #>   group_by(species) %>% #>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) #>  #> # Indirection ---------------------------------------- #> # Refer to column names stored as strings with the `.data` pronoun: #> vars <- c(\"mass\", \"height\") #> mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]]) #> # Learn more in ?rlang::args_data_masking #>   #> iris <- as_tibble(iris) #>  #> # All variants can be passed functions and additional arguments, #> # purrr-style. The _at() variants directly support strings. Here #> # we'll scale the variables `height` and `mass`: #> scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm) #> starwars %>% mutate_at(c(\"height\", \"mass\"), scale2) #> # -> #> starwars %>% mutate(across(c(\"height\", \"mass\"), scale2)) #>  #> # You can pass additional arguments to the function: #> starwars %>% mutate_at(c(\"height\", \"mass\"), scale2, na.rm = TRUE) #> starwars %>% mutate_at(c(\"height\", \"mass\"), ~scale2(., na.rm = TRUE)) #> # -> #> starwars %>% mutate(across(c(\"height\", \"mass\"), ~ scale2(.x, na.rm = TRUE))) #>  #> # You can also supply selection helpers to _at() functions but you have #> # to quote them with vars(): #> iris %>% mutate_at(vars(matches(\"Sepal\")), log) #> iris %>% mutate(across(matches(\"Sepal\"), log)) #>  #> # The _if() variants apply a predicate function (a function that #> # returns TRUE or FALSE) to determine the relevant subset of #> # columns. Here we divide all the numeric columns by 100: #> starwars %>% mutate_if(is.numeric, scale2, na.rm = TRUE) #> starwars %>% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE))) #>  #> # mutate_if() is particularly useful for transforming variables from #> # one type to another #> iris %>% mutate_if(is.factor, as.character) #> iris %>% mutate_if(is.double, as.integer) #> # -> #> iris %>% mutate(across(where(is.factor), as.character)) #> iris %>% mutate(across(where(is.double), as.integer)) #>  #> # Multiple transformations ---------------------------------------- #>  #> # If you want to apply multiple transformations, pass a list of #> # functions. When there are multiple functions, they create new #> # variables instead of modifying the variables in place: #> iris %>% mutate_if(is.numeric, list(scale2, log)) #> iris %>% mutate_if(is.numeric, list(~scale2(.), ~log(.))) #> iris %>% mutate_if(is.numeric, list(scale = scale2, log = log)) #> # -> #> iris %>% #>   as_tibble() %>% #>   mutate(across(where(is.numeric), list(scale = scale2, log = log))) #>  #> # When there's only one function in the list, it modifies existing #> # variables in place. Give it a name to instead create new variables: #> iris %>% mutate_if(is.numeric, list(scale2)) #> iris %>% mutate_if(is.numeric, list(scale = scale2)) #>   #> x <- c(1, 1, 2, 2, 2) #> n_distinct(x) #>  #> y <- c(3, 3, NA, 3, 3) #> n_distinct(y) #> n_distinct(y, na.rm = TRUE) #>  #> # Pairs (1, 3), (2, 3), and (2, NA) are distinct #> n_distinct(x, y) #>  #> # (2, NA) is dropped, leaving 2 distinct combinations #> n_distinct(x, y, na.rm = TRUE) #>  #> # Also works with data frames #> n_distinct(data.frame(x, y)) #>   #> na_if(1:5, 5:1) #>  #> x <- c(1, -1, 0, 10) #> 100 / x #> 100 / na_if(x, 0) #>  #> y <- c(\"abc\", \"def\", \"\", \"ghi\") #> na_if(y, \"\") #>  #> # `na_if()` allows you to replace `NaN` with `NA`, #> # even though `NaN == NaN` returns `NA` #> z <- c(1, NaN, NA, 2, NaN) #> na_if(z, NaN) #>  #> # `na_if()` is particularly useful inside `mutate()`, #> # and is meant for use with vectors rather than entire data frames #> starwars %>% #>   select(name, eye_color) %>% #>   mutate(eye_color = na_if(eye_color, \"unknown\")) #>  #> # `na_if()` can also be used with `mutate()` and `across()` #> # to alter multiple columns #> starwars %>% #>    mutate(across(where(is.character), ~na_if(., \"unknown\"))) #>   #> sqrt(2) ^ 2 == 2 #> near(sqrt(2) ^ 2, 2) #>   #> # After nesting, you get one row per group #> iris %>% nest_by(Species) #> starwars %>% nest_by(species) #>  #> # The output is grouped by row, which makes modelling particularly easy #> models <- mtcars %>% #>   nest_by(cyl) %>% #>   mutate(model = list(lm(mpg ~ wt, data = data))) #> models #>  #> models %>% summarise(rsq = summary(model)$r.squared) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # This is particularly elegant with the broom functions #> models %>% summarise(broom::glance(model)) #> models %>% reframe(broom::tidy(model)) #> \\dontshow{}) # examplesIf} #>  #> # Note that you can also `reframe()` to unnest the data #> models %>% reframe(data) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = c(2, 3, 3), y = c(\"a\", \"b\", \"c\")) #>  #> out <- nest_join(df1, df2) #> out #> out$df2 #>   #> # 5 bootstrap samples #> tbl <- new_grouped_df( #>   tibble(x = rnorm(10)), #>   groups = tibble(\".rows\" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE)) #> ) #> # mean of each bootstrap sample #> summarise(tbl, x = mean(x)) #>  #>   #> x <- 1:10 #> y <- 10:1 #>  #> first(x) #> last(y) #>  #> nth(x, 1) #> nth(x, 5) #> nth(x, -2) #>  #> # `first()` and `last()` are often useful in `summarise()` #> df <- tibble(x = x, y = y) #> df %>% #>   summarise( #>     across(x:y, first, .names = \"{col}_first\"), #>     y_last = last(y) #>   ) #>  #> # Selecting a position that is out of bounds returns a default value #> nth(x, 11) #> nth(x, 0) #>  #> # This out of bounds behavior also applies to empty vectors #> first(integer()) #>  #> # You can customize the default value with `default` #> nth(x, 11, default = -1L) #> first(integer(), default = 0L) #>  #> # `order_by` provides optional ordering #> last(x) #> last(x, order_by = y) #>  #> # `na_rm` removes missing values before extracting the value #> z <- c(NA, NA, 1, 3, NA, 5, NA) #> first(z) #> first(z, na_rm = TRUE) #> last(z, na_rm = TRUE) #> nth(z, 3, na_rm = TRUE) #>  #> # For data frames, these select entire rows #> df <- tibble(a = 1:5, b = 6:10) #> first(df) #> nth(df, 4) #>   #> x <- c(5, 1, 3, 2, 2, NA) #> ntile(x, 2) #> ntile(x, 4) #>  #> # If the bucket sizes are uneven, the larger buckets come first #> ntile(1:8, 3) #>  #> # Ties are ignored #> ntile(rep(1, 8), 3) #>   #> order_by(10:1, cumsum(1:10)) #> x <- 10:1 #> y <- 1:10 #> order_by(x, cumsum(y)) #>  #> df <- data.frame(year = 2000:2005, value = (0:5) ^ 2) #> scrambled <- df[sample(nrow(df)), ] #>  #> wrong <- mutate(scrambled, running = cumsum(value)) #> arrange(wrong, year) #>  #> right <- mutate(scrambled, running = order_by(year, cumsum(value))) #> arrange(right, year) #>   #> x <- c(5, 1, 3, 2, 2) #>  #> cume_dist(x) #> percent_rank(x) #>  #> # You can understand what's going on by computing it by hand #> sapply(x, function(xi) sum(x <= xi) / length(x)) #> sapply(x, function(xi) sum(x < xi)  / (length(x) - 1)) #> # The real computations are a little more complex in order to #> # correctly deal with missing values #>   #> df <- tibble( #>   x = c(3, 2, 2, 2, 1), #>   y = c(0, 2, 1, 1, 4), #>   z1 = c(\"a\", \"a\", \"a\", \"b\", \"a\"), #>   z2 = c(\"c\", \"d\", \"d\", \"a\", \"c\") #> ) #> df #>  #> # `pick()` provides a way to select a subset of your columns using #> # tidyselect. It returns a data frame. #> df %>% mutate(cols = pick(x, y)) #>  #> # This is useful for functions that take data frames as inputs. #> # For example, you can compute a joint rank between `x` and `y`. #> df %>% mutate(rank = dense_rank(pick(x, y))) #>  #> # `pick()` is also useful as a bridge between data-masking functions (like #> # `mutate()` or `group_by()`) and functions with tidy-select behavior (like #> # `select()`). For example, you can use `pick()` to create a wrapper around #> # `group_by()` that takes a tidy-selection of columns to group on. For more #> # bridge patterns, see #> # https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns. #> my_group_by <- function(data, cols) { #>   group_by(data, pick({{ cols }})) #> } #>  #> df %>% my_group_by(c(x, starts_with(\"z\"))) #>  #> # Or you can use it to dynamically select columns to `count()` by #> df %>% count(pick(starts_with(\"z\"))) #>   #> p <- progress_estimated(3) #> p$tick() #> p$tick() #> p$tick() #>  #> p <- progress_estimated(3) #> for (i in 1:3) p$pause(0.1)$tick()$print() #>  #> p <- progress_estimated(3) #> p$tick()$print()$ #>  pause(1)$stop() #>  #> # If min_time is set, progress bar not shown until that many #> # seconds have elapsed #> p <- progress_estimated(3, min_time = 3) #> for (i in 1:3) p$pause(0.1)$tick()$print() #>  #> \\dontrun{ #> p <- progress_estimated(10, min_time = 3) #> for (i in 1:10) p$pause(0.5)$tick()$print() #> } #>   #> mtcars %>% pull(-1) #> mtcars %>% pull(1) #> mtcars %>% pull(cyl) #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # Also works for remote sources #> df <- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = \"pull-ex\") #> df %>% #>   mutate(z = x * y) %>% #>   pull() #> \\dontshow{}) # examplesIf} #>  #> # Pull a named vector #> starwars %>% pull(height, name) #>   #> char_vec <- sample(c(\"a\", \"b\", \"c\"), 10, replace = TRUE) #>  #> # `recode()` is superseded by `case_match()` #> recode(char_vec, a = \"Apple\", b = \"Banana\") #> case_match(char_vec, \"a\" ~ \"Apple\", \"b\" ~ \"Banana\", .default = char_vec) #>  #> # With `case_match()`, you don't need typed missings like `NA_character_` #> recode(char_vec, a = \"Apple\", b = \"Banana\", .default = NA_character_) #> case_match(char_vec, \"a\" ~ \"Apple\", \"b\" ~ \"Banana\", .default = NA) #>  #> # Throws an error as `NA` is logical, not character. #> try(recode(char_vec, a = \"Apple\", b = \"Banana\", .default = NA)) #>  #> # `case_match()` is easier to use with numeric vectors, because you don't #> # need to turn the numeric values into names #> num_vec <- c(1:4, NA) #> recode(num_vec, `2` = 20L, `4` = 40L) #> case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec) #>  #> # `case_match()` doesn't have the ability to match by position like #> # `recode()` does with numeric vectors #> recode(num_vec, \"a\", \"b\", \"c\", \"d\") #> recode(c(1,5,3), \"a\", \"b\", \"c\", \"d\", .default = \"nothing\") #>  #> # For `case_match()`, incompatible types are an error rather than a warning #> recode(num_vec, `2` = \"b\", `4` = \"d\") #> try(case_match(num_vec, 2 ~ \"b\", 4 ~ \"d\", .default = num_vec)) #>  #> # The factor method of `recode()` can generally be replaced with #> # `forcats::fct_recode()` #> factor_vec <- factor(c(\"a\", \"b\", \"c\")) #> recode(factor_vec, a = \"Apple\") #>  #> # `recode_factor()` does not currently have a direct replacement, but we #> # plan to add one to forcats. In the meantime, you can use the `.ptype` #> # argument to `case_match()`. #> recode_factor( #>   num_vec, #>   `1` = \"z\", #>   `2` = \"y\", #>   `3` = \"x\", #>   .default = \"D\", #>   .missing = \"M\" #> ) #> case_match( #>   num_vec, #>   1 ~ \"z\", #>   2 ~ \"y\", #>   3 ~ \"x\", #>   NA ~ \"M\", #>   .default = \"D\", #>   .ptype = factor(levels = c(\"z\", \"y\", \"x\", \"D\", \"M\")) #> ) #>  NULL  #> table <- c(\"a\", \"b\", \"d\", \"f\") #>  #> df <- tibble( #>   g = c(1, 1, 1, 2, 2, 2, 2), #>   x = c(\"e\", \"a\", \"b\", \"c\", \"f\", \"d\", \"a\") #> ) #>  #> # `reframe()` allows you to apply functions that return #> # an arbitrary number of rows #> df %>% #>   reframe(x = intersect(x, table)) #>  #> # Functions are applied per group, and each group can return a #> # different number of rows. #> df %>% #>   reframe(x = intersect(x, table), .by = g) #>  #> # The output is always ungrouped, even when using `group_by()` #> df %>% #>   group_by(g) %>% #>   reframe(x = intersect(x, table)) #>  #> # You can add multiple columns at once using a single expression by returning #> # a data frame. #> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) { #>   tibble( #>     val = quantile(x, probs, na.rm = TRUE), #>     quant = probs #>   ) #> } #>  #> x <- c(10, 15, 18, 12) #> quantile_df(x) #>  #> starwars %>% #>   reframe(quantile_df(height)) #>  #> starwars %>% #>   reframe(quantile_df(height), .by = homeworld) #>  #> starwars %>% #>   reframe( #>     across(c(height, mass), quantile_df, .unpack = TRUE), #>     .by = homeworld #>   ) #>   #> df <- tibble(a = 1, b = 1, c = 1, d = \"a\", e = \"a\", f = \"a\") #> df %>% relocate(f) #> df %>% relocate(a, .after = c) #> df %>% relocate(f, .before = b) #> df %>% relocate(a, .after = last_col()) #>  #> # relocated columns can change name #> df %>% relocate(ff = f) #>  #> # Can also select variables based on their type #> df %>% relocate(where(is.character)) #> df %>% relocate(where(is.numeric), .after = last_col()) #> # Or with any other select helper #> df %>% relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\"))) #>  #> # When .before or .after refers to multiple variables they will be #> # moved to be immediately before/after the selected variables. #> df2 <- tibble(a = 1, b = \"a\", c = 1, d = \"a\") #> df2 %>% relocate(where(is.numeric), .after = where(is.character)) #> df2 %>% relocate(where(is.numeric), .before = where(is.character)) #>   #> iris <- as_tibble(iris) # so it prints a little nicer #> rename(iris, petal_length = Petal.Length) #>  #> # Rename using a named vector and `all_of()` #> lookup <- c(pl = \"Petal.Length\", sl = \"Sepal.Length\") #> rename(iris, all_of(lookup)) #>  #> # If your named vector might contain names that don't exist in the data, #> # use `any_of()` instead #> lookup <- c(lookup, new = \"unknown\") #> try(rename(iris, all_of(lookup))) #> rename(iris, any_of(lookup)) #>  #> rename_with(iris, toupper) #> rename_with(iris, toupper, starts_with(\"Petal\")) #> rename_with(iris, ~ tolower(gsub(\".\", \"_\", .x, fixed = TRUE))) #>  #> \\dontshow{if (getRversion() > \"4.0.1\") (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> # If your renaming function uses `paste0()`, make sure to set #> # `recycle0 = TRUE` to ensure that empty selections are recycled correctly #> try(rename_with( #>   iris, #>   ~ paste0(\"prefix_\", .x), #>   starts_with(\"nonexistent\") #> )) #>  #> rename_with( #>   iris, #>   ~ paste0(\"prefix_\", .x, recycle0 = TRUE), #>   starts_with(\"nonexistent\") #> ) #> \\dontshow{}) # examplesIf} #>   #> x <- c(5, 1, 3, 2, 2, NA) #> row_number(x) #> min_rank(x) #> dense_rank(x) #>  #> # Ranking functions can be used in `filter()` to select top/bottom rows #> df <- data.frame( #>   grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3), #>   x = c(3, 2, 1, 1, 2, 2, 1, 1, 1), #>   y = c(1, 3, 2, 3, 2, 2, 4, 1, 2), #>   id = 1:9 #> ) #> # Always gives exactly 1 row per group #> df %>% group_by(grp) %>% filter(row_number(x) == 1) #> # May give more than 1 row if ties #> df %>% group_by(grp) %>% filter(min_rank(x) == 1) #> # Rank by multiple columns (to break ties) by selecting them with `pick()` #> df %>% group_by(grp) %>% filter(min_rank(pick(x, y)) == 1) #> # See slice_min() and slice_max() for another way to tackle the same problem #>  #> # You can use row_number() without an argument to refer to the \"current\" #> # row number. #> df %>% group_by(grp) %>% filter(row_number() == 1) #>  #> # It's easiest to see what this does with mutate(): #> df %>% group_by(grp) %>% mutate(grp_id = row_number()) #>   #> data <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2) #> data #>  #> # Insert #> rows_insert(data, tibble(a = 4, b = \"z\")) #>  #> # By default, if a key in `y` matches a key in `x`, then it can't be inserted #> # and will throw an error. Alternatively, you can ignore rows in `y` #> # containing keys that conflict with keys in `x` with `conflict = \"ignore\"`, #> # or you can use `rows_append()` to ignore keys entirely. #> try(rows_insert(data, tibble(a = 3, b = \"z\"))) #> rows_insert(data, tibble(a = 3, b = \"z\"), conflict = \"ignore\") #> rows_append(data, tibble(a = 3, b = \"z\")) #>  #> # Update #> rows_update(data, tibble(a = 2:3, b = \"z\")) #> rows_update(data, tibble(b = \"z\", a = 2:3), by = \"a\") #>  #> # Variants: patch and upsert #> rows_patch(data, tibble(a = 2:3, b = \"z\")) #> rows_upsert(data, tibble(a = 2:4, b = \"z\")) #>  #> # Delete and truncate #> rows_delete(data, tibble(a = 2:3)) #> rows_delete(data, tibble(a = 2:3, b = \"b\")) #>  #> # By default, for update, patch, and delete it is an error if a key in `y` #> # doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys #> # with `unmatched = \"ignore\"`. #> y <- tibble(a = 3:4, b = \"z\") #> try(rows_update(data, y, by = \"a\")) #> rows_update(data, y, by = \"a\", unmatched = \"ignore\") #> rows_patch(data, y, by = \"a\", unmatched = \"ignore\") #> rows_delete(data, y, by = \"a\", unmatched = \"ignore\") #>   #> df <- tibble(x = runif(6), y = runif(6), z = runif(6)) #> # Compute the mean of x, y, z in each row #> df %>% rowwise() %>% mutate(m = mean(c(x, y, z))) #> # use c_across() to more easily select many variables #> df %>% rowwise() %>% mutate(m = mean(c_across(x:z))) #>  #> # Compute the minimum of x and y in each row #> df %>% rowwise() %>% mutate(m = min(c(x, y, z))) #> # In this case you can use an existing vectorised function: #> df %>% mutate(m = pmin(x, y, z)) #> # Where these functions exist they'll be much faster than rowwise #> # so be on the lookout for them. #>  #> # rowwise() is also useful when doing simulations #> params <- tribble( #>  ~sim, ~n, ~mean, ~sd, #>     1,  1,     1,   1, #>     2,  2,     2,   4, #>     3,  3,    -1,   2 #> ) #> # Here I supply variables to preserve after the computation #> params %>% #>   rowwise(sim) %>% #>   reframe(z = rnorm(n, mean, sd)) #>  #> # If you want one row per simulation, put the results in a list() #> params %>% #>   rowwise(sim) %>% #>   summarise(z = list(rnorm(n, mean, sd)), .groups = \"keep\") #>  NULL  #> df <- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2)) #>  #> # sample_n() -> slice_sample() ---------------------------------------------- #> # Was: #> sample_n(df, 3) #> sample_n(df, 10, replace = TRUE) #> sample_n(df, 3, weight = w) #>  #> # Now: #> slice_sample(df, n = 3) #> slice_sample(df, n = 10, replace = TRUE) #> slice_sample(df, n = 3, weight_by = w) #>  #> # Note that sample_n() would error if n was bigger than the group size #> # slice_sample() will just use the available rows for consistency with #> # the other slice helpers like slice_head() #> try(sample_n(df, 10)) #> slice_sample(df, n = 10) #>  #> # sample_frac() -> slice_sample() ------------------------------------------- #> # Was: #> sample_frac(df, 0.25) #> sample_frac(df, 2, replace = TRUE) #>  #> # Now: #> slice_sample(df, prop = 0.25) #> slice_sample(df, prop = 2, replace = TRUE) #>  NULL NULL NULL  #> mtcars <- as_tibble(mtcars) # for nicer printing #>  #> mtcars %>% rename_all(toupper) #> # -> #> mtcars %>% rename_with(toupper) #>  #> # NB: the transformation comes first in rename_with #> is_whole <- function(x) all(floor(x) == x) #> mtcars %>% rename_if(is_whole, toupper) #> # -> #> mtcars %>% rename_with(toupper, where(is_whole)) #>  #> mtcars %>% rename_at(vars(mpg:hp), toupper) #> # -> #> mtcars %>% rename_with(toupper, mpg:hp) #>  #> # You now must select() and then rename #>  #> mtcars %>% select_all(toupper) #> # -> #> mtcars %>% rename_with(toupper) #>  #> # Selection drops unselected variables: #> mtcars %>% select_if(is_whole, toupper) #> # -> #> mtcars %>% select(where(is_whole)) %>% rename_with(toupper) #>  #> mtcars %>% select_at(vars(-contains(\"ar\"), starts_with(\"c\")), toupper) #> # -> #> mtcars %>% #>   select(!contains(\"ar\") | starts_with(\"c\")) %>% #>   rename_with(toupper) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = 3:5) #>  #> intersect(df1, df2) #> union(df1, df2) #> union_all(df1, df2) #> setdiff(df1, df2) #> setdiff(df2, df1) #> symdiff(df1, df2) #>  #> setequal(df1, df2) #> setequal(df1, df1[3:1, ]) #>  #> # Note that the following functions remove pre-existing duplicates: #> df1 <- tibble(x = c(1:3, 3, 3)) #> df2 <- tibble(x = c(3:5, 5)) #>  #> intersect(df1, df2) #> union(df1, df2) #> setdiff(df1, df2) #> symdiff(df1, df2) #>   #> # Similar to head(mtcars, 1): #> mtcars %>% slice(1L) #> # Similar to tail(mtcars, 1): #> mtcars %>% slice(n()) #> mtcars %>% slice(5:n()) #> # Rows can be dropped with negative indices: #> slice(mtcars, -(1:4)) #>  #> # First and last rows based on existing order #> mtcars %>% slice_head(n = 5) #> mtcars %>% slice_tail(n = 5) #>  #> # Rows with minimum and maximum values of a variable #> mtcars %>% slice_min(mpg, n = 5) #> mtcars %>% slice_max(mpg, n = 5) #>  #> # slice_min() and slice_max() may return more rows than requested #> # in the presence of ties. #> mtcars %>% slice_min(cyl, n = 1) #> # Use with_ties = FALSE to return exactly n matches #> mtcars %>% slice_min(cyl, n = 1, with_ties = FALSE) #> # Or use additional variables to break the tie: #> mtcars %>% slice_min(tibble(cyl, mpg), n = 1) #>  #> # slice_sample() allows you to random select with or without replacement #> mtcars %>% slice_sample(n = 5) #> mtcars %>% slice_sample(n = 5, replace = TRUE) #>  #> # you can optionally weight by a variable - this code weights by the #> # physical weight of the cars, so heavy cars are more likely to get #> # selected #> mtcars %>% slice_sample(weight_by = wt, n = 5) #>  #> # Group wise operation ---------------------------------------- #> df <- tibble( #>   group = rep(c(\"a\", \"b\", \"c\"), c(1, 2, 4)), #>   x = runif(7) #> ) #>  #> # All slice helpers operate per group, silently truncating to the group #> # size, so the following code works without error #> df %>% group_by(group) %>% slice_head(n = 2) #>  #> # When specifying the proportion of rows to include non-integer sizes #> # are rounded down, so group a gets 0 rows #> df %>% group_by(group) %>% slice_head(prop = 0.5) #>  #> # Filter equivalents -------------------------------------------- #> # slice() expressions can often be written to use `filter()` and #> # `row_number()`, which can also be translated to SQL. For many databases, #> # you'll need to supply an explicit variable to use to compute the row number. #> filter(mtcars, row_number() == 1L) #> filter(mtcars, row_number() == n()) #> filter(mtcars, between(row_number(), 5, n())) #>  NULL NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") #> copy_to(con, mtcars) #>  #> # To retrieve a single table from a source, use `tbl()` #> mtcars <- con %>% tbl(\"mtcars\") #> mtcars #>  #> # You can also use pass raw SQL if you want a more sophisticated query #> con %>% tbl(sql(\"SELECT * FROM mtcars WHERE cyl == 8\")) #> \\dontshow{}) # examplesIf} #>  NULL NULL  #> starwars #>   #> storms #>  #> # Show a few recent storm paths #> if (requireNamespace(\"ggplot2\", quietly = TRUE)) { #>   library(ggplot2) #>   storms %>% #>     filter(year >= 2000) %>% #>     ggplot(aes(long, lat, color = paste(year, name))) + #>     geom_path(show.legend = FALSE) + #>     facet_wrap(~year) #> } #>  #> storms #>   #> # A summary applied to ungrouped tbl returns a single row #> mtcars %>% #>   summarise(mean = mean(disp), n = n()) #>  #> # Usually, you'll want to group first #> mtcars %>% #>   group_by(cyl) %>% #>   summarise(mean = mean(disp), n = n()) #>  #> # Each summary call removes one grouping level (since that group #> # is now just a single row) #> mtcars %>% #>   group_by(cyl, vs) %>% #>   summarise(cyl_n = n()) %>% #>   group_vars() #>  #> # BEWARE: reusing variables may lead to unexpected results #> mtcars %>% #>   group_by(cyl) %>% #>   summarise(disp = mean(disp), sd = sd(disp)) #>  #> # Refer to column names stored as strings with the `.data` pronoun: #> var <- \"mass\" #> summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE)) #> # Learn more in ?rlang::args_data_masking #>  #> # In dplyr 1.1.0, returning multiple rows per group was deprecated in favor #> # of `reframe()`, which never messages and always returns an ungrouped #> # result: #> mtcars %>% #>    group_by(cyl) %>% #>    summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75)) #> # -> #> mtcars %>% #>    group_by(cyl) %>% #>    reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75)) #>   #> # The _at() variants directly support strings: #> starwars %>% #>   summarise_at(c(\"height\", \"mass\"), mean, na.rm = TRUE) #> # -> #> starwars %>% summarise(across(c(\"height\", \"mass\"), ~ mean(.x, na.rm = TRUE))) #>  #> # You can also supply selection helpers to _at() functions but you have #> # to quote them with vars(): #> starwars %>% #>   summarise_at(vars(height:mass), mean, na.rm = TRUE) #> # -> #> starwars %>% #>   summarise(across(height:mass, ~ mean(.x, na.rm = TRUE))) #>  #> # The _if() variants apply a predicate function (a function that #> # returns TRUE or FALSE) to determine the relevant subset of #> # columns. Here we apply mean() to the numeric columns: #> starwars %>% #>   summarise_if(is.numeric, mean, na.rm = TRUE) #> starwars %>% #>   summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) #>  #> by_species <- iris %>% #>   group_by(Species) #>  #> # If you want to apply multiple transformations, pass a list of #> # functions. When there are multiple functions, they create new #> # variables instead of modifying the variables in place: #> by_species %>% #>   summarise_all(list(min, max)) #> # -> #> by_species %>% #>   summarise(across(everything(), list(min = min, max = max))) #>  NULL NULL NULL NULL NULL NULL  #> df <- data.frame(x = c(6, 4, 1, 10, 3, 1, 1)) #>  #> df %>% top_n(2)  # highest values #> df %>% top_n(-2) # lowest values #> # now use #> df %>% slice_max(x, n = 2) #> df %>% slice_min(x, n = 2) #>  #> # top_frac() -> prop argument of slice_min()/slice_max() #> df %>% top_frac(.5) #> # -> #> df %>% slice_max(x, prop = 0.5) #>  NULL NULL  #> df <- tibble(g = c(1, 1, 2, 2, 3), x = runif(5)) #>  #> # Old #> df %>% #>   with_groups(g, mutate, x_mean = mean(x)) #> # New #> df %>% mutate(x_mean = mean(x), .by = g) #>  NULL forgot_exmpls(dplyr, count, write = FALSE) #>  #> # For better printing #> iris <- as_tibble(iris) #>  #> # across() ----------------------------------------------------------------- #> # Different ways to select the same set of columns #> # See <https://tidyselect.r-lib.org/articles/syntax.html> for details #> iris %>% #>   mutate(across(c(Sepal.Length, Sepal.Width), round)) #> iris %>% #>   mutate(across(c(1, 2), round)) #> iris %>% #>   mutate(across(1:Sepal.Width, round)) #> iris %>% #>   mutate(across(where(is.double) & !c(Petal.Length, Petal.Width), round)) #>  #> # Using an external vector of names #> cols <- c(\"Sepal.Length\", \"Petal.Width\") #> iris %>% #>   mutate(across(all_of(cols), round)) #>  #> # If the external vector is named, the output columns will be named according #> # to those names #> names(cols) <- tolower(cols) #> iris %>% #>   mutate(across(all_of(cols), round)) #>  #> # A purrr-style formula #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), ~ mean(.x, na.rm = TRUE))) #>  #> # A named list of functions #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd))) #>  #> # Use the .names argument to control the output names #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), mean, .names = \"mean_{.col}\")) #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd), .names = \"{.col}.{.fn}\")) #>  #> # If a named external vector is used for column selection, .names will use #> # those names when constructing the output names #> iris %>% #>   group_by(Species) %>% #>   summarise(across(all_of(cols), mean, .names = \"mean_{.col}\")) #>  #> # When the list is not named, .fn is replaced by the function's position #> iris %>% #>   group_by(Species) %>% #>   summarise(across(starts_with(\"Sepal\"), list(mean, sd), .names = \"{.col}.fn{.fn}\")) #>  #> # When the functions in .fns return a data frame, you typically get a #> # \"packed\" data frame back #> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) { #>   tibble(quantile = probs, value = quantile(x, probs)) #> } #>  #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df)) #>  #> # Use .unpack to automatically expand these packed data frames into their #> # individual columns #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df, .unpack = TRUE)) #>  #> # .unpack can utilize a glue specification if you don't like the defaults #> iris %>% #>   reframe(across(starts_with(\"Sepal\"), quantile_df, .unpack = \"{outer}.{inner}\")) #>  #> # This is also useful inside mutate(), for example, with a multi-lag helper #> multilag <- function(x, lags = 1:3) { #>   names(lags) <- as.character(lags) #>   purrr::map_dfr(lags, lag, x = x) #> } #>  #> iris %>% #>   group_by(Species) %>% #>   mutate(across(starts_with(\"Sepal\"), multilag, .unpack = TRUE)) %>% #>   select(Species, starts_with(\"Sepal\")) #>  #> # if_any() and if_all() ---------------------------------------------------- #> iris %>% #>   filter(if_any(ends_with(\"Width\"), ~ . > 4)) #> iris %>% #>   filter(if_all(ends_with(\"Width\"), ~ . > 2)) #>  #>  NULL  #> scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))] #>  #> # `all_equal()` ignored row and column ordering by default, #> # but we now feel that that makes it too easy to make mistakes #> mtcars2 <- scramble(mtcars) #> all_equal(mtcars, mtcars2) #>  #> # Instead, be explicit about the row and column ordering #> all.equal( #>   mtcars, #>   mtcars2[rownames(mtcars), names(mtcars)] #> ) #>  NULL NULL  #> arrange(mtcars, cyl, disp) #> arrange(mtcars, desc(disp)) #>  #> # grouped arrange ignores groups #> by_cyl <- mtcars %>% group_by(cyl) #> by_cyl %>% arrange(desc(wt)) #> # Unless you specifically ask: #> by_cyl %>% arrange(desc(wt), .by_group = TRUE) #>  #> # use embracing when wrapping in a function; #> # see ?rlang::args_data_masking for more details #> tidy_eval_arrange <- function(.data, var) { #>   .data %>% #>     arrange({{ var }}) #> } #> tidy_eval_arrange(mtcars, mpg) #>  #> # Use `across()` or `pick()` to select columns with tidy-select #> iris %>% arrange(pick(starts_with(\"Sepal\"))) #> iris %>% arrange(across(starts_with(\"Sepal\"), desc)) #>   #> df <- as_tibble(mtcars) #> arrange_all(df) #> # -> #> arrange(df, pick(everything())) #>  #> arrange_all(df, desc) #> # -> #> arrange(df, across(everything(), desc)) #>  NULL NULL  #> band_members #> band_instruments #> band_instruments2 #>   #> between(1:12, 7, 9) #>  #> x <- rnorm(1e2) #> x[between(x, -1, 1)] #>  #> # On a tibble using `filter()` #> filter(starwars, between(height, 100, 150)) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(y = 3:1) #> bind_cols(df1, df2) #>  #> # Row sizes must be compatible when column-binding #> try(bind_cols(tibble(x = 1:3), tibble(y = 1:2))) #>   #> df1 <- tibble(x = 1:2, y = letters[1:2]) #> df2 <- tibble(x = 4:5, z = 1:2) #>  #> # You can supply individual data frames as arguments: #> bind_rows(df1, df2) #>  #> # Or a list of data frames: #> bind_rows(list(df1, df2)) #>  #> # When you supply a column name with the `.id` argument, a new #> # column is created to link each row to its original data frame #> bind_rows(list(df1, df2), .id = \"id\") #> bind_rows(list(a = df1, b = df2), .id = \"id\") #>   #> df <- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4)) #> df %>% #>   rowwise() %>% #>   mutate( #>     sum = sum(c_across(w:z)), #>     sd = sd(c_across(w:z)) #>   ) #>   #> x <- c(\"a\", \"b\", \"a\", \"d\", \"b\", NA, \"c\", \"e\") #>  #> # `case_match()` acts like a vectorized `switch()`. #> # Unmatched values \"fall through\" as a missing value. #> case_match( #>   x, #>   \"a\" ~ 1, #>   \"b\" ~ 2, #>   \"c\" ~ 3, #>   \"d\" ~ 4 #> ) #>  #> # Missing values can be matched exactly, and `.default` can be used to #> # control the value used for unmatched values of `.x` #> case_match( #>   x, #>   \"a\" ~ 1, #>   \"b\" ~ 2, #>   \"c\" ~ 3, #>   \"d\" ~ 4, #>   NA ~ 0, #>   .default = 100 #> ) #>  #> # Input values can be grouped into the same expression to map them to the #> # same output value #> case_match( #>   x, #>   c(\"a\", \"b\") ~ \"low\", #>   c(\"c\", \"d\", \"e\") ~ \"high\" #> ) #>  #> # `case_match()` isn't limited to character input: #> y <- c(1, 2, 1, 3, 1, NA, 2, 4) #>  #> case_match( #>   y, #>   c(1, 3) ~ \"odd\", #>   c(2, 4) ~ \"even\", #>   .default = \"missing\" #> ) #>  #> # Setting `.default` to the original vector is a useful way to replace #> # selected values, leaving everything else as is #> case_match(y, NA ~ 0, .default = y) #>  #> starwars %>% #>   mutate( #>     # Replace missings, but leave everything else alone #>     hair_color = case_match(hair_color, NA ~ \"unknown\", .default = hair_color), #>     # Replace some, but not all, of the species #>     species = case_match( #>       species, #>       \"Human\" ~ \"Humanoid\", #>       \"Droid\" ~ \"Robot\", #>       c(\"Wookiee\", \"Ewok\") ~ \"Hairy\", #>       .default = species #>     ), #>     .keep = \"used\" #>   ) #>   #> x <- 1:70 #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #>   .default = as.character(x) #> ) #>  #> # Like an if statement, the arguments are evaluated in order, so you must #> # proceed from the most specific to the most general. This won't work: #> case_when( #>   x %%  5 == 0 ~ \"fizz\", #>   x %%  7 == 0 ~ \"buzz\", #>   x %% 35 == 0 ~ \"fizz buzz\", #>   .default = as.character(x) #> ) #>  #> # If none of the cases match and no `.default` is supplied, NA is used: #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #> ) #>  #> # Note that `NA` values on the LHS are treated like `FALSE` and will be #> # assigned the `.default` value. You must handle them explicitly if you #> # want to use a different value. The exact way to handle missing values is #> # dependent on the set of LHS conditions you use. #> x[2:4] <- NA_real_ #> case_when( #>   x %% 35 == 0 ~ \"fizz buzz\", #>   x %% 5 == 0 ~ \"fizz\", #>   x %% 7 == 0 ~ \"buzz\", #>   is.na(x) ~ \"nope\", #>   .default = as.character(x) #> ) #>  #> # `case_when()` evaluates all RHS expressions, and then constructs its #> # result by extracting the selected (via the LHS expressions) parts. #> # In particular `NaN`s are produced in this case: #> y <- seq(-2, 2, by = .5) #> case_when( #>   y >= 0 ~ sqrt(y), #>   .default = y #> ) #>  #> # `case_when()` is particularly useful inside `mutate()` when you want to #> # create a new variable that relies on a complex combination of existing #> # variables #> starwars %>% #>   select(name:mass, gender, species) %>% #>   mutate( #>     type = case_when( #>       height > 200 | mass > 200 ~ \"large\", #>       species == \"Droid\" ~ \"robot\", #>       .default = \"other\" #>     ) #>   ) #>  #>  #> # `case_when()` is not a tidy eval function. If you'd like to reuse #> # the same patterns, extract the `case_when()` call in a normal #> # function: #> case_character_type <- function(height, mass, species) { #>   case_when( #>     height > 200 | mass > 200 ~ \"large\", #>     species == \"Droid\" ~ \"robot\", #>     .default = \"other\" #>   ) #> } #>  #> case_character_type(150, 250, \"Droid\") #> case_character_type(150, 150, \"Droid\") #>  #> # Such functions can be used inside `mutate()` as well: #> starwars %>% #>   mutate(type = case_character_type(height, mass, species)) %>% #>   pull(type) #>  #> # `case_when()` ignores `NULL` inputs. This is useful when you'd #> # like to use a pattern only under certain conditions. Here we'll #> # take advantage of the fact that `if` returns `NULL` when there is #> # no `else` clause: #> case_character_type <- function(height, mass, species, robots = TRUE) { #>   case_when( #>     height > 200 | mass > 200 ~ \"large\", #>     if (robots) species == \"Droid\" ~ \"robot\", #>     .default = \"other\" #>   ) #> } #>  #> starwars %>% #>   mutate(type = case_character_type(height, mass, species, robots = FALSE)) %>% #>   pull(type) #>   #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> wrap_dbplyr_obj(\"build_sql\") #> wrap_dbplyr_obj(\"base_agg\") #> \\dontshow{}) # examplesIf} #>   #> # Use a single value to replace all missing values #> x <- sample(c(1:5, NA, NA, NA)) #> coalesce(x, 0L) #>  #> # The equivalent to a missing value in a list is `NULL` #> coalesce(list(1, 2, NULL), list(NA)) #>  #> # Or generate a complete vector from partially missing pieces #> y <- c(1, 2, NA, NA, 5) #> z <- c(NA, NA, 3, 4, 5) #> coalesce(y, z) #>  #> # Supply lists by splicing them into dots: #> vecs <- list( #>   c(1, 2, NA, NA, 5), #>   c(NA, NA, 3, 4, 5) #> ) #> coalesce(!!!vecs) #>   #> f1 <- factor(\"a\") #> f2 <- factor(\"b\") #>  #> combine(f1, f2) #> # -> #> vctrs::vec_c(f1, f1) #>  #> combine(list(f1, f2)) #> # -> #> vctrs::vec_c(!!!list(f1, f2)) #>  NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> mtcars2 <- dbplyr::src_memdb() %>% #>   copy_to(mtcars, name = \"mtcars2-cc\", overwrite = TRUE) #>  #> remote <- mtcars2 %>% #>   filter(cyl == 8) %>% #>   select(mpg:drat) #>  #> # Compute query and save in remote table #> compute(remote) #>  #> # Compute query bring back to this session #> collect(remote) #>  #> # Creates a fresh query based on the generated SQL #> collapse(remote) #> \\dontshow{}) # examplesIf} #>   #> consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA)) #> consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2)) #>  #> df <- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2)) #> df %>% group_by(x, y) %>% summarise(n = n()) #> df %>% group_by(id = consecutive_id(x, y), x, y) %>% summarise(n = n()) #>   #> df <- tibble( #>   g = sample(rep(letters[1:3], 1:3)), #>   x = runif(6), #>   y = runif(6) #> ) #> gf <- df %>% group_by(g) #>  #> gf %>% summarise(n = n()) #>  #> gf %>% mutate(id = cur_group_id()) #> gf %>% reframe(row = cur_group_rows()) #> gf %>% summarise(data = list(cur_group())) #>  #> gf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2)))) #>   #> \\dontrun{ #> iris2 <- dbplyr::src_memdb() %>% copy_to(iris, overwrite = TRUE) #> iris2 #> } #>   #> # count() is a convenient way to get a sense of the distribution of #> # values in a dataset #> starwars %>% count(species) #> starwars %>% count(species, sort = TRUE) #> starwars %>% count(sex, gender, sort = TRUE) #> starwars %>% count(birth_decade = round(birth_year, -1)) #>  #> # use the `wt` argument to perform a weighted count. This is useful #> # when the data has already been aggregated once #> df <- tribble( #>   ~name,    ~gender,   ~runs, #>   \"Max\",    \"male\",       10, #>   \"Sandra\", \"female\",      1, #>   \"Susan\",  \"female\",      4 #> ) #> # counts rows: #> df %>% count(gender) #> # counts runs: #> df %>% count(gender, wt = runs) #>  #> # When factors are involved, `.drop = FALSE` can be used to retain factor #> # levels that don't appear in the data #> df2 <- tibble( #>   id = 1:5, #>   type = factor(c(\"a\", \"c\", \"a\", NA, \"a\"), levels = c(\"a\", \"b\", \"c\")) #> ) #> df2 %>% count(type) #> df2 %>% count(type, .drop = FALSE) #>  #> # Or, using `group_by()`: #> df2 %>% group_by(type, .drop = FALSE) %>% count() #>  #> # tally() is a lower-level function that assumes you've done the grouping #> starwars %>% tally() #> starwars %>% group_by(species) %>% tally() #>  #> # both count() and tally() have add_ variants that work like #> # mutate() instead of summarise #> df %>% add_count(gender, wt = runs) #> df %>% add_tally(wt = runs) #>   #> # Cross joins match each row in `x` to every row in `y`. #> # Data within the columns is not used in the matching process. #> cross_join(band_instruments, band_members) #>  #> # Control the suffix added to variables duplicated in #> # `x` and `y` with `suffix`. #> cross_join(band_instruments, band_members, suffix = c(\"\", \"_y\")) #>   #> # `cummean()` returns a numeric/integer vector of the same length #> # as the input vector. #> x <- c(1, 3, 5, 2, 2) #> cummean(x) #> cumsum(x) / seq_along(x) #>  #> # `cumall()` and `cumany()` return logicals #> cumall(x < 5) #> cumany(x == 3) #>  #> # `cumall()` vs. `cumany()` #> df <- data.frame( #>   date = as.Date(\"2020-01-01\") + 0:6, #>   balance = c(100, 50, 25, -25, -50, 30, 120) #> ) #> # all rows after first overdraft #> df %>% filter(cumany(balance < 0)) #> # all rows until first overdraft #> df %>% filter(cumall(!(balance < 0))) #>  #>  NULL NULL  #> desc(1:10) #> desc(factor(letters)) #>  #> first_day <- seq(as.Date(\"1910/1/1\"), as.Date(\"1920/1/1\"), \"years\") #> desc(first_day) #>  #> starwars %>% arrange(desc(mass)) #>   #> dim_desc(mtcars) #>   #> df <- tibble( #>   x = sample(10, 100, rep = TRUE), #>   y = sample(10, 100, rep = TRUE) #> ) #> nrow(df) #> nrow(distinct(df)) #> nrow(distinct(df, x, y)) #>  #> distinct(df, x) #> distinct(df, y) #>  #> # You can choose to keep all other variables as well #> distinct(df, x, .keep_all = TRUE) #> distinct(df, y, .keep_all = TRUE) #>  #> # You can also use distinct on computed variables #> distinct(df, diff = abs(x - y)) #>  #> # Use `pick()` to select columns with tidy-select #> distinct(starwars, pick(contains(\"color\"))) #>  #> # Grouping ------------------------------------------------- #>  #> df <- tibble( #>   g = c(1, 1, 2, 2, 2), #>   x = c(1, 1, 2, 1, 2), #>   y = c(3, 2, 1, 3, 1) #> ) #> df <- df %>% group_by(g) #>  #> # With grouped data frames, distinctness is computed within each group #> df %>% distinct(x) #>  #> # When `...` are omitted, `distinct()` still computes distinctness using #> # all variables in the data frame #> df %>% distinct() #>   #> df <- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2) #>  #> distinct_all(df) #> # -> #> distinct(df, pick(everything())) #>  #> distinct_at(df, vars(x,y)) #> # -> #> distinct(df, pick(x, y)) #>  #> distinct_if(df, is.numeric) #> # -> #> distinct(df, pick(where(is.numeric))) #>  #> # You can supply a function that will be applied before extracting the distinct values #> # The variables of the sorted tibble keep their original values. #> distinct_all(df, round) #> # -> #> distinct(df, across(everything(), round)) #>   #> # do() with unnamed arguments becomes reframe() or summarise() #> # . becomes pick() #> by_cyl <- mtcars %>% group_by(cyl) #> by_cyl %>% do(head(., 2)) #> # -> #> by_cyl %>% reframe(head(pick(everything()), 2)) #> by_cyl %>% slice_head(n = 2) #>  #> # Can refer to variables directly #> by_cyl %>% do(mean = mean(.$vs)) #> # -> #> by_cyl %>% summarise(mean = mean(vs)) #>  #> # do() with named arguments becomes nest_by() + mutate() & list() #> models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .)) #> # -> #> models <- mtcars %>% #>   nest_by(cyl) %>% #>   mutate(mod = list(lm(mpg ~ disp, data = data))) #> models %>% summarise(rsq = summary(mod)$r.squared) #>  #> # use broom to turn models into data #> models %>% do(data.frame( #>   var = names(coef(.$mod)), #>   coef(summary(.$mod))) #> ) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> # -> #> models %>% reframe(broom::tidy(mod)) #> \\dontshow{}) # examplesIf} #>   #> \\dontshow{if (dplyr:::has_minimum_stringi()) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> df <- tibble(x = c(\"a\", \"b\", \"C\", \"B\", \"c\")) #> df #>  #> # Default locale is C, which groups the English alphabet by case, placing #> # uppercase letters before lowercase letters. #> arrange(df, x) #>  #> # The American English locale groups the alphabet by letter. #> # Explicitly override `.locale` with `\"en\"` for this ordering. #> arrange(df, x, .locale = \"en\") #>  #> # This Danish letter is expected to sort after `z` #> df <- tibble(x = c(\"o\", \"p\", \"\\u00F8\", \"z\")) #> df #>  #> # The American English locale sorts it right after `o` #> arrange(df, x, .locale = \"en\") #>  #> # Using `\"da\"` for Danish ordering gives the expected result #> arrange(df, x, .locale = \"da\") #>  #> # If you need the legacy behavior of `arrange()`, which respected the #> # system locale, then you can set the global option `dplyr.legacy_locale`, #> # but expect this to be removed in the future. We recommend that you use #> # the `.locale` argument instead. #> rlang::with_options(dplyr.legacy_locale = TRUE, { #>   arrange(df, x) #> }) #> \\dontshow{}) # examplesIf} #>  NULL NULL NULL NULL NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> \\donttest{ #> lahman_s <- dbplyr::lahman_sqlite() #> batting <- tbl(lahman_s, \"Batting\") #> batting %>% show_query() #> batting %>% explain() #>  #> # The batting database has indices on all ID variables: #> # SQLite automatically picks the most restrictive index #> batting %>% filter(lgID == \"NL\" & yearID == 2000L) %>% explain() #>  #> # OR's will use multiple indexes #> batting %>% filter(lgID == \"NL\" | yearID == 2000) %>% explain() #>  #> # Joins will use indexes in both tables #> teams <- tbl(lahman_s, \"Teams\") #> batting %>% left_join(teams, c(\"yearID\", \"teamID\")) %>% explain() #> } #> \\dontshow{}) # examplesIf} #>   #> # \"Filtering\" joins keep cases from the LHS #> band_members %>% semi_join(band_instruments) #> band_members %>% anti_join(band_instruments) #>  #> # To suppress the message about joining variables, supply `by` #> band_members %>% semi_join(band_instruments, by = join_by(name)) #> # This is good practice in production code #>   #> # Filtering by one criterion #> filter(starwars, species == \"Human\") #> filter(starwars, mass > 1000) #>  #> # Filtering by multiple criteria within a single logical expression #> filter(starwars, hair_color == \"none\" & eye_color == \"black\") #> filter(starwars, hair_color == \"none\" | eye_color == \"black\") #>  #> # When multiple expressions are used, they are combined using & #> filter(starwars, hair_color == \"none\", eye_color == \"black\") #>  #>  #> # The filtering operation may yield different results on grouped #> # tibbles because the expressions are computed within groups. #> # #> # The following filters rows where `mass` is greater than the #> # global average: #> starwars %>% filter(mass > mean(mass, na.rm = TRUE)) #>  #> # Whereas this keeps rows with `mass` greater than the gender #> # average: #> starwars %>% group_by(gender) %>% filter(mass > mean(mass, na.rm = TRUE)) #>  #>  #> # To refer to column names that are stored as strings, use the `.data` pronoun: #> vars <- c(\"mass\", \"height\") #> cond <- c(80, 150) #> starwars %>% #>   filter( #>     .data[[vars[[1]]]] > cond[[1]], #>     .data[[vars[[2]]]] > cond[[2]] #>   ) #> # Learn more in ?rlang::args_data_masking #>   #> # While filter() accepts expressions with specific variables, the #> # scoped filter verbs take an expression with the pronoun `.` and #> # replicate it over all variables. This expression should be quoted #> # with all_vars() or any_vars(): #> all_vars(is.na(.)) #> any_vars(is.na(.)) #>  #>  #> # You can take the intersection of the replicated expressions: #> filter_all(mtcars, all_vars(. > 150)) #> # -> #> filter(mtcars, if_all(everything(), ~ .x > 150)) #>  #> # Or the union: #> filter_all(mtcars, any_vars(. > 150)) #> # -> #> filter(mtcars, if_any(everything(), ~ . > 150)) #>  #>  #> # You can vary the selection of columns on which to apply the #> # predicate. filter_at() takes a vars() specification: #> filter_at(mtcars, vars(starts_with(\"d\")), any_vars((. %% 2) == 0)) #> # -> #> filter(mtcars, if_any(starts_with(\"d\"), ~ (.x %% 2) == 0)) #>  #> # And filter_if() selects variables with a predicate function: #> filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0)) #> # -> #> is_int <- function(x) all(floor(x) == x) #> filter(mtcars, if_all(where(is_int), ~ .x != 0)) #>   #> funs(\"mean\", mean(., na.rm = TRUE)) #> # -> #> list(mean = mean, mean = ~ mean(.x, na.rm = TRUE)) #>  #> funs(m1 = mean, m2 = \"mean\", m3 = mean(., na.rm = TRUE)) #> # -> #> list(m1 = mean, m2 = \"mean\", m3 = ~ mean(.x, na.rm = TRUE)) #>   #> glimpse(mtcars) #>  #> # Note that original x is (invisibly) returned, allowing `glimpse()` to be #> # used within a pipeline. #> mtcars %>% #>   glimpse() %>% #>   select(1:3) #>  #> glimpse(starwars) #>   #> by_cyl <- mtcars %>% group_by(cyl) #>  #> # grouping doesn't change how the data looks (apart from listing #> # how it's grouped): #> by_cyl #>  #> # It changes how it acts with the other dplyr verbs: #> by_cyl %>% summarise( #>   disp = mean(disp), #>   hp = mean(hp) #> ) #> by_cyl %>% filter(disp == max(disp)) #>  #> # Each call to summarise() removes a layer of grouping #> by_vs_am <- mtcars %>% group_by(vs, am) #> by_vs <- by_vs_am %>% summarise(n = n()) #> by_vs #> by_vs %>% summarise(n = sum(n)) #>  #> # To removing grouping, use ungroup #> by_vs %>% #>   ungroup() %>% #>   summarise(n = sum(n)) #>  #> # By default, group_by() overrides existing grouping #> by_cyl %>% #>   group_by(vs, am) %>% #>   group_vars() #>  #> # Use add = TRUE to instead append #> by_cyl %>% #>   group_by(vs, am, .add = TRUE) %>% #>   group_vars() #>  #> # You can group by expressions: this is a short-hand #> # for a mutate() followed by a group_by() #> mtcars %>% #>   group_by(vsam = vs + am) #>  #> # The implicit mutate() step is always performed on the #> # ungrouped data. Here we get 3 groups: #> mtcars %>% #>   group_by(vs) %>% #>   group_by(hp_cut = cut(hp, 3)) #>  #> # If you want it to be performed by groups, #> # you have to use an explicit mutate() call. #> # Here we get 3 groups per value of vs #> mtcars %>% #>   group_by(vs) %>% #>   mutate(hp_cut = cut(hp, 3)) %>% #>   group_by(hp_cut) #>  #> # when factors are involved and .drop = FALSE, groups can be empty #> tbl <- tibble( #>   x = 1:10, #>   y = factor(rep(c(\"a\", \"c\"), each  = 5), levels = c(\"a\", \"b\", \"c\")) #> ) #> tbl %>% #>   group_by(y, .drop = FALSE) %>% #>   group_rows() #>  #>   #> # Group a data frame by all variables: #> group_by_all(mtcars) #> # -> #> mtcars %>% group_by(pick(everything())) #>  #> # Group by variables selected with a predicate: #> group_by_if(iris, is.factor) #> # -> #> iris %>% group_by(pick(where(is.factor))) #>  #> # Group by variables selected by name: #> group_by_at(mtcars, vars(vs, am)) #> # -> #> mtcars %>% group_by(pick(vs, am)) #>  #> # Like group_by(), the scoped variants have optional mutate #> # semantics. This provide a shortcut for group_by() + mutate(): #> d <- tibble(x=c(1,1,2,2), y=c(1,2,1,2)) #> group_by_all(d, as.factor) #> # -> #> d %>% group_by(across(everything(), as.factor)) #>  #> group_by_if(iris, is.factor, as.character) #> # -> #> iris %>% group_by(across(where(is.factor), as.character)) #>   #> group_by_drop_default(iris) #>  #> iris %>% #>   group_by(Species) %>% #>   group_by_drop_default() #>  #> iris %>% #>   group_by(Species, .drop = FALSE) %>% #>   group_by_drop_default() #>  #>  NULL  #> gdf <- iris %>% group_by(Species) #> gdf %>% select(group_cols()) #>  #> # Remove the grouping variables from mutate selections: #> gdf %>% mutate_at(vars(-group_cols()), `/`, 100) #> # -> No longer necessary with across() #> gdf %>% mutate(across(everything(), ~ . / 100)) #>   #> df <- tibble(x = c(1,1,2,2)) #> group_vars(df) #> group_rows(df) #> group_data(df) #> group_indices(df) #>  #> gf <- group_by(df, x) #> group_vars(gf) #> group_rows(gf) #> group_data(gf) #> group_indices(gf) #>   #>  #> # return a list #> mtcars %>% #>   group_by(cyl) %>% #>   group_map(~ head(.x, 2L)) #>  #> # return a tibble grouped by `cyl` with 2 rows per group #> # the grouping data is recalculated #> mtcars %>% #>   group_by(cyl) %>% #>   group_modify(~ head(.x, 2L)) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # a list of tibbles #> iris %>% #>   group_by(Species) %>% #>   group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) #>  #> # a restructured grouped tibble #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) #> \\dontshow{}) # examplesIf} #>  #> # a list of vectors #> iris %>% #>   group_by(Species) %>% #>   group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75))) #>  #> # to use group_modify() the lambda must return a data frame #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ { #>      quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %>% #>      tibble::enframe(name = \"prob\", value = \"quantile\") #>   }) #>  #> iris %>% #>   group_by(Species) %>% #>   group_modify(~ { #>     .x %>% #>       purrr::map_dfc(fivenum) %>% #>       mutate(nms = c(\"min\", \"Q1\", \"median\", \"Q3\", \"max\")) #>   }) #>  #> # group_walk() is for side effects #> dir.create(temp <- tempfile()) #> iris %>% #>   group_by(Species) %>% #>   group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, \".csv\")))) #> list.files(temp, pattern = \"csv$\") #> unlink(temp, recursive = TRUE) #>  #> # group_modify() and ungrouped data frames #> mtcars %>% #>   group_modify(~ head(.x, 2L)) #>  #>   #>  #> #----- use case 1: a grouped data frame #> iris %>% #>   group_by(Species) %>% #>   group_nest() #>  #> # this can be useful if the grouped data has been altered before nesting #> iris %>% #>   group_by(Species) %>% #>   filter(Sepal.Length > mean(Sepal.Length)) %>% #>   group_nest() #>  #> #----- use case 2: using group_nest() on a ungrouped data frame with #> #                  a grouping specification that uses the data mask #> starwars %>% #>   group_nest(species, homeworld) #>   #> ir <- iris %>% group_by(Species) #>  #> group_split(ir) #> group_keys(ir) #>   #> iris %>% #>   group_by(Species) %>% #>   filter(Species == \"setosa\", .preserve = TRUE) %>% #>   group_trim() #>  NULL  #> # Identifiers are escaped with \" #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> ident(\"x\") #> \\dontshow{}) # examplesIf} #>   #> x <- c(-5:5, NA) #> if_else(x < 0, NA, x) #>  #> # Explicitly handle `NA` values in the `condition` with `missing` #> if_else(x < 0, \"negative\", \"positive\", missing = \"missing\") #>  #> # Unlike `ifelse()`, `if_else()` preserves types #> x <- factor(sample(letters[1:5], 10, replace = TRUE)) #> ifelse(x %in% c(\"a\", \"b\", \"c\"), x, NA) #> if_else(x %in% c(\"a\", \"b\", \"c\"), x, NA) #>  #> # `if_else()` is often useful for creating new columns inside of `mutate()` #> starwars %>% #>   mutate(category = if_else(height < 100, \"short\", \"tall\"), .keep = \"used\") #>   #> sales <- tibble( #>   id = c(1L, 1L, 1L, 2L, 2L), #>   sale_date = as.Date(c(\"2018-12-31\", \"2019-01-02\", \"2019-01-05\", \"2019-01-04\", \"2019-01-01\")) #> ) #> sales #>  #> promos <- tibble( #>   id = c(1L, 1L, 2L), #>   promo_date = as.Date(c(\"2019-01-01\", \"2019-01-05\", \"2019-01-02\")) #> ) #> promos #>  #> # Match `id` to `id`, and `sale_date` to `promo_date` #> by <- join_by(id, sale_date == promo_date) #> left_join(sales, promos, by) #>  #> # For each `sale_date` within a particular `id`, #> # find all `promo_date`s that occurred before that particular sale #> by <- join_by(id, sale_date >= promo_date) #> left_join(sales, promos, by) #>  #> # For each `sale_date` within a particular `id`, #> # find only the closest `promo_date` that occurred before that sale #> by <- join_by(id, closest(sale_date >= promo_date)) #> left_join(sales, promos, by) #>  #> # If you want to disallow exact matching in rolling joins, use `>` rather #> # than `>=`. Note that the promo on `2019-01-05` is no longer considered the #> # closest match for the sale on the same date. #> by <- join_by(id, closest(sale_date > promo_date)) #> left_join(sales, promos, by) #>  #> # Same as before, but also require that the promo had to occur at most 1 #> # day before the sale was made. We'll use a full join to see that id 2's #> # promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`. #> sales <- mutate(sales, sale_date_lower = sale_date - 1) #> by <- join_by(id, closest(sale_date >= promo_date), sale_date_lower <= promo_date) #> full_join(sales, promos, by) #>  #> # --------------------------------------------------------------------------- #>  #> segments <- tibble( #>   segment_id = 1:4, #>   chromosome = c(\"chr1\", \"chr2\", \"chr2\", \"chr1\"), #>   start = c(140, 210, 380, 230), #>   end = c(150, 240, 415, 280) #> ) #> segments #>  #> reference <- tibble( #>   reference_id = 1:4, #>   chromosome = c(\"chr1\", \"chr1\", \"chr2\", \"chr2\"), #>   start = c(100, 200, 300, 415), #>   end = c(150, 250, 399, 450) #> ) #> reference #>  #> # Find every time a segment `start` falls between the reference #> # `[start, end]` range. #> by <- join_by(chromosome, between(start, start, end)) #> full_join(segments, reference, by) #>  #> # If you wanted the reference columns first, supply `reference` as `x` #> # and `segments` as `y`, then explicitly refer to their columns using `x$` #> # and `y$`. #> by <- join_by(chromosome, between(y$start, x$start, x$end)) #> full_join(reference, segments, by) #>  #> # Find every time a segment falls completely within a reference. #> # Sometimes using `x$` and `y$` makes your intentions clearer, even if they #> # match the default behavior. #> by <- join_by(chromosome, within(x$start, x$end, y$start, y$end)) #> inner_join(segments, reference, by) #>  #> # Find every time a segment overlaps a reference in any way. #> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end)) #> full_join(segments, reference, by) #>  #> # It is common to have right-open ranges with bounds like `[)`, which would #> # mean an end value of `415` would no longer overlap a start value of `415`. #> # Setting `bounds` allows you to compute overlaps with those kinds of ranges. #> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = \"[)\")) #> full_join(segments, reference, by) #>  NULL  #> lag(1:5) #> lead(1:5) #>  #> x <- 1:5 #> tibble(behind = lag(x), x, ahead = lead(x)) #>  #> # If you want to look more rows behind or ahead, use `n` #> lag(1:5, n = 1) #> lag(1:5, n = 2) #>  #> lead(1:5, n = 1) #> lead(1:5, n = 2) #>  #> # If you want to define a value to pad with, use `default` #> lag(1:5) #> lag(1:5, default = 0) #>  #> lead(1:5) #> lead(1:5, default = 6) #>  #> # If the data are not already ordered, use `order_by` #> scrambled <- slice_sample( #>   tibble(year = 2000:2005, value = (0:5) ^ 2), #>   prop = 1 #> ) #>  #> wrong <- mutate(scrambled, previous_year_value = lag(value)) #> arrange(wrong, year) #>  #> right <- mutate(scrambled, previous_year_value = lag(value, order_by = year)) #> arrange(right, year) #>  NULL  #> band_members %>% inner_join(band_instruments) #> band_members %>% left_join(band_instruments) #> band_members %>% right_join(band_instruments) #> band_members %>% full_join(band_instruments) #>  #> # To suppress the message about joining variables, supply `by` #> band_members %>% inner_join(band_instruments, by = join_by(name)) #> # This is good practice in production code #>  #> # Use an equality expression if the join variables have different names #> band_members %>% full_join(band_instruments2, by = join_by(name == artist)) #> # By default, the join keys from `x` and `y` are coalesced in the output; use #> # `keep = TRUE` to keep the join keys from both `x` and `y` #> band_members %>% #>   full_join(band_instruments2, by = join_by(name == artist), keep = TRUE) #>  #> # If a row in `x` matches multiple rows in `y`, all the rows in `y` will be #> # returned once for each matching row in `x`. #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = c(1, 1, 2), y = c(\"first\", \"second\", \"third\")) #> df1 %>% left_join(df2) #>  #> # If a row in `y` also matches multiple rows in `x`, this is known as a #> # many-to-many relationship, which is typically a result of an improperly #> # specified join or some kind of messy data. In this case, a warning is #> # thrown by default: #> df3 <- tibble(x = c(1, 1, 1, 3)) #> df3 %>% left_join(df2) #>  #> # In the rare case where a many-to-many relationship is expected, set #> # `relationship = \"many-to-many\"` to silence this warning #> df3 %>% left_join(df2, relationship = \"many-to-many\") #>  #> # Use `join_by()` with a condition other than `==` to perform an inequality #> # join. Here we match on every instance where `df1$x > df2$x`. #> df1 %>% left_join(df2, join_by(x > x)) #>  #> # By default, NAs match other NAs so that there are two #> # rows in the output of this join: #> df1 <- data.frame(x = c(1, NA), y = 2) #> df2 <- data.frame(x = c(1, NA), z = 3) #> left_join(df1, df2) #>  #> # You can optionally request that NAs don't match, giving a #> # a result that more closely resembles SQL joins #> left_join(df1, df2, na_matches = \"never\") #>   #> # Newly created variables are available immediately #> starwars %>% #>   select(name, mass) %>% #>   mutate( #>     mass2 = mass * 2, #>     mass2_squared = mass2 * mass2 #>   ) #>  #> # As well as adding new variables, you can use mutate() to #> # remove variables and modify existing variables. #> starwars %>% #>   select(name, height, mass, homeworld) %>% #>   mutate( #>     mass = NULL, #>     height = height * 0.0328084 # convert to feet #>   ) #>  #> # Use across() with mutate() to apply a transformation #> # to multiple columns in a tibble. #> starwars %>% #>   select(name, homeworld, species) %>% #>   mutate(across(!name, as.factor)) #> # see more in ?across #>  #> # Window functions are useful for grouped mutates: #> starwars %>% #>   select(name, mass, homeworld) %>% #>   group_by(homeworld) %>% #>   mutate(rank = min_rank(desc(mass))) #> # see `vignette(\"window-functions\")` for more details #>  #> # By default, new columns are placed on the far right. #> df <- tibble(x = 1, y = 2) #> df %>% mutate(z = x + y) #> df %>% mutate(z = x + y, .before = 1) #> df %>% mutate(z = x + y, .after = x) #>  #> # By default, mutate() keeps all columns from the input data. #> df <- tibble(x = 1, y = 2, a = \"a\", b = \"b\") #> df %>% mutate(z = x + y, .keep = \"all\") # the default #> df %>% mutate(z = x + y, .keep = \"used\") #> df %>% mutate(z = x + y, .keep = \"unused\") #> df %>% mutate(z = x + y, .keep = \"none\") #>  #> # Grouping ---------------------------------------- #> # The mutate operation may yield different results on grouped #> # tibbles because the expressions are computed within groups. #> # The following normalises `mass` by the global average: #> starwars %>% #>   select(name, mass, species) %>% #>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) #>  #> # Whereas this normalises `mass` by the averages within species #> # levels: #> starwars %>% #>   select(name, mass, species) %>% #>   group_by(species) %>% #>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE)) #>  #> # Indirection ---------------------------------------- #> # Refer to column names stored as strings with the `.data` pronoun: #> vars <- c(\"mass\", \"height\") #> mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]]) #> # Learn more in ?rlang::args_data_masking #>   #> iris <- as_tibble(iris) #>  #> # All variants can be passed functions and additional arguments, #> # purrr-style. The _at() variants directly support strings. Here #> # we'll scale the variables `height` and `mass`: #> scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm) #> starwars %>% mutate_at(c(\"height\", \"mass\"), scale2) #> # -> #> starwars %>% mutate(across(c(\"height\", \"mass\"), scale2)) #>  #> # You can pass additional arguments to the function: #> starwars %>% mutate_at(c(\"height\", \"mass\"), scale2, na.rm = TRUE) #> starwars %>% mutate_at(c(\"height\", \"mass\"), ~scale2(., na.rm = TRUE)) #> # -> #> starwars %>% mutate(across(c(\"height\", \"mass\"), ~ scale2(.x, na.rm = TRUE))) #>  #> # You can also supply selection helpers to _at() functions but you have #> # to quote them with vars(): #> iris %>% mutate_at(vars(matches(\"Sepal\")), log) #> iris %>% mutate(across(matches(\"Sepal\"), log)) #>  #> # The _if() variants apply a predicate function (a function that #> # returns TRUE or FALSE) to determine the relevant subset of #> # columns. Here we divide all the numeric columns by 100: #> starwars %>% mutate_if(is.numeric, scale2, na.rm = TRUE) #> starwars %>% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE))) #>  #> # mutate_if() is particularly useful for transforming variables from #> # one type to another #> iris %>% mutate_if(is.factor, as.character) #> iris %>% mutate_if(is.double, as.integer) #> # -> #> iris %>% mutate(across(where(is.factor), as.character)) #> iris %>% mutate(across(where(is.double), as.integer)) #>  #> # Multiple transformations ---------------------------------------- #>  #> # If you want to apply multiple transformations, pass a list of #> # functions. When there are multiple functions, they create new #> # variables instead of modifying the variables in place: #> iris %>% mutate_if(is.numeric, list(scale2, log)) #> iris %>% mutate_if(is.numeric, list(~scale2(.), ~log(.))) #> iris %>% mutate_if(is.numeric, list(scale = scale2, log = log)) #> # -> #> iris %>% #>   as_tibble() %>% #>   mutate(across(where(is.numeric), list(scale = scale2, log = log))) #>  #> # When there's only one function in the list, it modifies existing #> # variables in place. Give it a name to instead create new variables: #> iris %>% mutate_if(is.numeric, list(scale2)) #> iris %>% mutate_if(is.numeric, list(scale = scale2)) #>   #> x <- c(1, 1, 2, 2, 2) #> n_distinct(x) #>  #> y <- c(3, 3, NA, 3, 3) #> n_distinct(y) #> n_distinct(y, na.rm = TRUE) #>  #> # Pairs (1, 3), (2, 3), and (2, NA) are distinct #> n_distinct(x, y) #>  #> # (2, NA) is dropped, leaving 2 distinct combinations #> n_distinct(x, y, na.rm = TRUE) #>  #> # Also works with data frames #> n_distinct(data.frame(x, y)) #>   #> na_if(1:5, 5:1) #>  #> x <- c(1, -1, 0, 10) #> 100 / x #> 100 / na_if(x, 0) #>  #> y <- c(\"abc\", \"def\", \"\", \"ghi\") #> na_if(y, \"\") #>  #> # `na_if()` allows you to replace `NaN` with `NA`, #> # even though `NaN == NaN` returns `NA` #> z <- c(1, NaN, NA, 2, NaN) #> na_if(z, NaN) #>  #> # `na_if()` is particularly useful inside `mutate()`, #> # and is meant for use with vectors rather than entire data frames #> starwars %>% #>   select(name, eye_color) %>% #>   mutate(eye_color = na_if(eye_color, \"unknown\")) #>  #> # `na_if()` can also be used with `mutate()` and `across()` #> # to alter multiple columns #> starwars %>% #>    mutate(across(where(is.character), ~na_if(., \"unknown\"))) #>   #> sqrt(2) ^ 2 == 2 #> near(sqrt(2) ^ 2, 2) #>   #> # After nesting, you get one row per group #> iris %>% nest_by(Species) #> starwars %>% nest_by(species) #>  #> # The output is grouped by row, which makes modelling particularly easy #> models <- mtcars %>% #>   nest_by(cyl) %>% #>   mutate(model = list(lm(mpg ~ wt, data = data))) #> models #>  #> models %>% summarise(rsq = summary(model)$r.squared) #> \\dontshow{if (requireNamespace(\"broom\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # This is particularly elegant with the broom functions #> models %>% summarise(broom::glance(model)) #> models %>% reframe(broom::tidy(model)) #> \\dontshow{}) # examplesIf} #>  #> # Note that you can also `reframe()` to unnest the data #> models %>% reframe(data) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = c(2, 3, 3), y = c(\"a\", \"b\", \"c\")) #>  #> out <- nest_join(df1, df2) #> out #> out$df2 #>   #> # 5 bootstrap samples #> tbl <- new_grouped_df( #>   tibble(x = rnorm(10)), #>   groups = tibble(\".rows\" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE)) #> ) #> # mean of each bootstrap sample #> summarise(tbl, x = mean(x)) #>  #>   #> x <- 1:10 #> y <- 10:1 #>  #> first(x) #> last(y) #>  #> nth(x, 1) #> nth(x, 5) #> nth(x, -2) #>  #> # `first()` and `last()` are often useful in `summarise()` #> df <- tibble(x = x, y = y) #> df %>% #>   summarise( #>     across(x:y, first, .names = \"{col}_first\"), #>     y_last = last(y) #>   ) #>  #> # Selecting a position that is out of bounds returns a default value #> nth(x, 11) #> nth(x, 0) #>  #> # This out of bounds behavior also applies to empty vectors #> first(integer()) #>  #> # You can customize the default value with `default` #> nth(x, 11, default = -1L) #> first(integer(), default = 0L) #>  #> # `order_by` provides optional ordering #> last(x) #> last(x, order_by = y) #>  #> # `na_rm` removes missing values before extracting the value #> z <- c(NA, NA, 1, 3, NA, 5, NA) #> first(z) #> first(z, na_rm = TRUE) #> last(z, na_rm = TRUE) #> nth(z, 3, na_rm = TRUE) #>  #> # For data frames, these select entire rows #> df <- tibble(a = 1:5, b = 6:10) #> first(df) #> nth(df, 4) #>   #> x <- c(5, 1, 3, 2, 2, NA) #> ntile(x, 2) #> ntile(x, 4) #>  #> # If the bucket sizes are uneven, the larger buckets come first #> ntile(1:8, 3) #>  #> # Ties are ignored #> ntile(rep(1, 8), 3) #>   #> order_by(10:1, cumsum(1:10)) #> x <- 10:1 #> y <- 1:10 #> order_by(x, cumsum(y)) #>  #> df <- data.frame(year = 2000:2005, value = (0:5) ^ 2) #> scrambled <- df[sample(nrow(df)), ] #>  #> wrong <- mutate(scrambled, running = cumsum(value)) #> arrange(wrong, year) #>  #> right <- mutate(scrambled, running = order_by(year, cumsum(value))) #> arrange(right, year) #>   #> x <- c(5, 1, 3, 2, 2) #>  #> cume_dist(x) #> percent_rank(x) #>  #> # You can understand what's going on by computing it by hand #> sapply(x, function(xi) sum(x <= xi) / length(x)) #> sapply(x, function(xi) sum(x < xi)  / (length(x) - 1)) #> # The real computations are a little more complex in order to #> # correctly deal with missing values #>   #> df <- tibble( #>   x = c(3, 2, 2, 2, 1), #>   y = c(0, 2, 1, 1, 4), #>   z1 = c(\"a\", \"a\", \"a\", \"b\", \"a\"), #>   z2 = c(\"c\", \"d\", \"d\", \"a\", \"c\") #> ) #> df #>  #> # `pick()` provides a way to select a subset of your columns using #> # tidyselect. It returns a data frame. #> df %>% mutate(cols = pick(x, y)) #>  #> # This is useful for functions that take data frames as inputs. #> # For example, you can compute a joint rank between `x` and `y`. #> df %>% mutate(rank = dense_rank(pick(x, y))) #>  #> # `pick()` is also useful as a bridge between data-masking functions (like #> # `mutate()` or `group_by()`) and functions with tidy-select behavior (like #> # `select()`). For example, you can use `pick()` to create a wrapper around #> # `group_by()` that takes a tidy-selection of columns to group on. For more #> # bridge patterns, see #> # https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns. #> my_group_by <- function(data, cols) { #>   group_by(data, pick({{ cols }})) #> } #>  #> df %>% my_group_by(c(x, starts_with(\"z\"))) #>  #> # Or you can use it to dynamically select columns to `count()` by #> df %>% count(pick(starts_with(\"z\"))) #>   #> p <- progress_estimated(3) #> p$tick() #> p$tick() #> p$tick() #>  #> p <- progress_estimated(3) #> for (i in 1:3) p$pause(0.1)$tick()$print() #>  #> p <- progress_estimated(3) #> p$tick()$print()$ #>  pause(1)$stop() #>  #> # If min_time is set, progress bar not shown until that many #> # seconds have elapsed #> p <- progress_estimated(3, min_time = 3) #> for (i in 1:3) p$pause(0.1)$tick()$print() #>  #> \\dontrun{ #> p <- progress_estimated(10, min_time = 3) #> for (i in 1:10) p$pause(0.5)$tick()$print() #> } #>   #> mtcars %>% pull(-1) #> mtcars %>% pull(1) #> mtcars %>% pull(cyl) #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #>  #> # Also works for remote sources #> df <- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = \"pull-ex\") #> df %>% #>   mutate(z = x * y) %>% #>   pull() #> \\dontshow{}) # examplesIf} #>  #> # Pull a named vector #> starwars %>% pull(height, name) #>   #> char_vec <- sample(c(\"a\", \"b\", \"c\"), 10, replace = TRUE) #>  #> # `recode()` is superseded by `case_match()` #> recode(char_vec, a = \"Apple\", b = \"Banana\") #> case_match(char_vec, \"a\" ~ \"Apple\", \"b\" ~ \"Banana\", .default = char_vec) #>  #> # With `case_match()`, you don't need typed missings like `NA_character_` #> recode(char_vec, a = \"Apple\", b = \"Banana\", .default = NA_character_) #> case_match(char_vec, \"a\" ~ \"Apple\", \"b\" ~ \"Banana\", .default = NA) #>  #> # Throws an error as `NA` is logical, not character. #> try(recode(char_vec, a = \"Apple\", b = \"Banana\", .default = NA)) #>  #> # `case_match()` is easier to use with numeric vectors, because you don't #> # need to turn the numeric values into names #> num_vec <- c(1:4, NA) #> recode(num_vec, `2` = 20L, `4` = 40L) #> case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec) #>  #> # `case_match()` doesn't have the ability to match by position like #> # `recode()` does with numeric vectors #> recode(num_vec, \"a\", \"b\", \"c\", \"d\") #> recode(c(1,5,3), \"a\", \"b\", \"c\", \"d\", .default = \"nothing\") #>  #> # For `case_match()`, incompatible types are an error rather than a warning #> recode(num_vec, `2` = \"b\", `4` = \"d\") #> try(case_match(num_vec, 2 ~ \"b\", 4 ~ \"d\", .default = num_vec)) #>  #> # The factor method of `recode()` can generally be replaced with #> # `forcats::fct_recode()` #> factor_vec <- factor(c(\"a\", \"b\", \"c\")) #> recode(factor_vec, a = \"Apple\") #>  #> # `recode_factor()` does not currently have a direct replacement, but we #> # plan to add one to forcats. In the meantime, you can use the `.ptype` #> # argument to `case_match()`. #> recode_factor( #>   num_vec, #>   `1` = \"z\", #>   `2` = \"y\", #>   `3` = \"x\", #>   .default = \"D\", #>   .missing = \"M\" #> ) #> case_match( #>   num_vec, #>   1 ~ \"z\", #>   2 ~ \"y\", #>   3 ~ \"x\", #>   NA ~ \"M\", #>   .default = \"D\", #>   .ptype = factor(levels = c(\"z\", \"y\", \"x\", \"D\", \"M\")) #> ) #>  NULL  #> table <- c(\"a\", \"b\", \"d\", \"f\") #>  #> df <- tibble( #>   g = c(1, 1, 1, 2, 2, 2, 2), #>   x = c(\"e\", \"a\", \"b\", \"c\", \"f\", \"d\", \"a\") #> ) #>  #> # `reframe()` allows you to apply functions that return #> # an arbitrary number of rows #> df %>% #>   reframe(x = intersect(x, table)) #>  #> # Functions are applied per group, and each group can return a #> # different number of rows. #> df %>% #>   reframe(x = intersect(x, table), .by = g) #>  #> # The output is always ungrouped, even when using `group_by()` #> df %>% #>   group_by(g) %>% #>   reframe(x = intersect(x, table)) #>  #> # You can add multiple columns at once using a single expression by returning #> # a data frame. #> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) { #>   tibble( #>     val = quantile(x, probs, na.rm = TRUE), #>     quant = probs #>   ) #> } #>  #> x <- c(10, 15, 18, 12) #> quantile_df(x) #>  #> starwars %>% #>   reframe(quantile_df(height)) #>  #> starwars %>% #>   reframe(quantile_df(height), .by = homeworld) #>  #> starwars %>% #>   reframe( #>     across(c(height, mass), quantile_df, .unpack = TRUE), #>     .by = homeworld #>   ) #>   #> df <- tibble(a = 1, b = 1, c = 1, d = \"a\", e = \"a\", f = \"a\") #> df %>% relocate(f) #> df %>% relocate(a, .after = c) #> df %>% relocate(f, .before = b) #> df %>% relocate(a, .after = last_col()) #>  #> # relocated columns can change name #> df %>% relocate(ff = f) #>  #> # Can also select variables based on their type #> df %>% relocate(where(is.character)) #> df %>% relocate(where(is.numeric), .after = last_col()) #> # Or with any other select helper #> df %>% relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\"))) #>  #> # When .before or .after refers to multiple variables they will be #> # moved to be immediately before/after the selected variables. #> df2 <- tibble(a = 1, b = \"a\", c = 1, d = \"a\") #> df2 %>% relocate(where(is.numeric), .after = where(is.character)) #> df2 %>% relocate(where(is.numeric), .before = where(is.character)) #>   #> iris <- as_tibble(iris) # so it prints a little nicer #> rename(iris, petal_length = Petal.Length) #>  #> # Rename using a named vector and `all_of()` #> lookup <- c(pl = \"Petal.Length\", sl = \"Sepal.Length\") #> rename(iris, all_of(lookup)) #>  #> # If your named vector might contain names that don't exist in the data, #> # use `any_of()` instead #> lookup <- c(lookup, new = \"unknown\") #> try(rename(iris, all_of(lookup))) #> rename(iris, any_of(lookup)) #>  #> rename_with(iris, toupper) #> rename_with(iris, toupper, starts_with(\"Petal\")) #> rename_with(iris, ~ tolower(gsub(\".\", \"_\", .x, fixed = TRUE))) #>  #> \\dontshow{if (getRversion() > \"4.0.1\") (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> # If your renaming function uses `paste0()`, make sure to set #> # `recycle0 = TRUE` to ensure that empty selections are recycled correctly #> try(rename_with( #>   iris, #>   ~ paste0(\"prefix_\", .x), #>   starts_with(\"nonexistent\") #> )) #>  #> rename_with( #>   iris, #>   ~ paste0(\"prefix_\", .x, recycle0 = TRUE), #>   starts_with(\"nonexistent\") #> ) #> \\dontshow{}) # examplesIf} #>   #> x <- c(5, 1, 3, 2, 2, NA) #> row_number(x) #> min_rank(x) #> dense_rank(x) #>  #> # Ranking functions can be used in `filter()` to select top/bottom rows #> df <- data.frame( #>   grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3), #>   x = c(3, 2, 1, 1, 2, 2, 1, 1, 1), #>   y = c(1, 3, 2, 3, 2, 2, 4, 1, 2), #>   id = 1:9 #> ) #> # Always gives exactly 1 row per group #> df %>% group_by(grp) %>% filter(row_number(x) == 1) #> # May give more than 1 row if ties #> df %>% group_by(grp) %>% filter(min_rank(x) == 1) #> # Rank by multiple columns (to break ties) by selecting them with `pick()` #> df %>% group_by(grp) %>% filter(min_rank(pick(x, y)) == 1) #> # See slice_min() and slice_max() for another way to tackle the same problem #>  #> # You can use row_number() without an argument to refer to the \"current\" #> # row number. #> df %>% group_by(grp) %>% filter(row_number() == 1) #>  #> # It's easiest to see what this does with mutate(): #> df %>% group_by(grp) %>% mutate(grp_id = row_number()) #>   #> data <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2) #> data #>  #> # Insert #> rows_insert(data, tibble(a = 4, b = \"z\")) #>  #> # By default, if a key in `y` matches a key in `x`, then it can't be inserted #> # and will throw an error. Alternatively, you can ignore rows in `y` #> # containing keys that conflict with keys in `x` with `conflict = \"ignore\"`, #> # or you can use `rows_append()` to ignore keys entirely. #> try(rows_insert(data, tibble(a = 3, b = \"z\"))) #> rows_insert(data, tibble(a = 3, b = \"z\"), conflict = \"ignore\") #> rows_append(data, tibble(a = 3, b = \"z\")) #>  #> # Update #> rows_update(data, tibble(a = 2:3, b = \"z\")) #> rows_update(data, tibble(b = \"z\", a = 2:3), by = \"a\") #>  #> # Variants: patch and upsert #> rows_patch(data, tibble(a = 2:3, b = \"z\")) #> rows_upsert(data, tibble(a = 2:4, b = \"z\")) #>  #> # Delete and truncate #> rows_delete(data, tibble(a = 2:3)) #> rows_delete(data, tibble(a = 2:3, b = \"b\")) #>  #> # By default, for update, patch, and delete it is an error if a key in `y` #> # doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys #> # with `unmatched = \"ignore\"`. #> y <- tibble(a = 3:4, b = \"z\") #> try(rows_update(data, y, by = \"a\")) #> rows_update(data, y, by = \"a\", unmatched = \"ignore\") #> rows_patch(data, y, by = \"a\", unmatched = \"ignore\") #> rows_delete(data, y, by = \"a\", unmatched = \"ignore\") #>   #> df <- tibble(x = runif(6), y = runif(6), z = runif(6)) #> # Compute the mean of x, y, z in each row #> df %>% rowwise() %>% mutate(m = mean(c(x, y, z))) #> # use c_across() to more easily select many variables #> df %>% rowwise() %>% mutate(m = mean(c_across(x:z))) #>  #> # Compute the minimum of x and y in each row #> df %>% rowwise() %>% mutate(m = min(c(x, y, z))) #> # In this case you can use an existing vectorised function: #> df %>% mutate(m = pmin(x, y, z)) #> # Where these functions exist they'll be much faster than rowwise #> # so be on the lookout for them. #>  #> # rowwise() is also useful when doing simulations #> params <- tribble( #>  ~sim, ~n, ~mean, ~sd, #>     1,  1,     1,   1, #>     2,  2,     2,   4, #>     3,  3,    -1,   2 #> ) #> # Here I supply variables to preserve after the computation #> params %>% #>   rowwise(sim) %>% #>   reframe(z = rnorm(n, mean, sd)) #>  #> # If you want one row per simulation, put the results in a list() #> params %>% #>   rowwise(sim) %>% #>   summarise(z = list(rnorm(n, mean, sd)), .groups = \"keep\") #>  NULL  #> df <- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2)) #>  #> # sample_n() -> slice_sample() ---------------------------------------------- #> # Was: #> sample_n(df, 3) #> sample_n(df, 10, replace = TRUE) #> sample_n(df, 3, weight = w) #>  #> # Now: #> slice_sample(df, n = 3) #> slice_sample(df, n = 10, replace = TRUE) #> slice_sample(df, n = 3, weight_by = w) #>  #> # Note that sample_n() would error if n was bigger than the group size #> # slice_sample() will just use the available rows for consistency with #> # the other slice helpers like slice_head() #> try(sample_n(df, 10)) #> slice_sample(df, n = 10) #>  #> # sample_frac() -> slice_sample() ------------------------------------------- #> # Was: #> sample_frac(df, 0.25) #> sample_frac(df, 2, replace = TRUE) #>  #> # Now: #> slice_sample(df, prop = 0.25) #> slice_sample(df, prop = 2, replace = TRUE) #>  NULL NULL NULL  #> mtcars <- as_tibble(mtcars) # for nicer printing #>  #> mtcars %>% rename_all(toupper) #> # -> #> mtcars %>% rename_with(toupper) #>  #> # NB: the transformation comes first in rename_with #> is_whole <- function(x) all(floor(x) == x) #> mtcars %>% rename_if(is_whole, toupper) #> # -> #> mtcars %>% rename_with(toupper, where(is_whole)) #>  #> mtcars %>% rename_at(vars(mpg:hp), toupper) #> # -> #> mtcars %>% rename_with(toupper, mpg:hp) #>  #> # You now must select() and then rename #>  #> mtcars %>% select_all(toupper) #> # -> #> mtcars %>% rename_with(toupper) #>  #> # Selection drops unselected variables: #> mtcars %>% select_if(is_whole, toupper) #> # -> #> mtcars %>% select(where(is_whole)) %>% rename_with(toupper) #>  #> mtcars %>% select_at(vars(-contains(\"ar\"), starts_with(\"c\")), toupper) #> # -> #> mtcars %>% #>   select(!contains(\"ar\") | starts_with(\"c\")) %>% #>   rename_with(toupper) #>   #> df1 <- tibble(x = 1:3) #> df2 <- tibble(x = 3:5) #>  #> intersect(df1, df2) #> union(df1, df2) #> union_all(df1, df2) #> setdiff(df1, df2) #> setdiff(df2, df1) #> symdiff(df1, df2) #>  #> setequal(df1, df2) #> setequal(df1, df1[3:1, ]) #>  #> # Note that the following functions remove pre-existing duplicates: #> df1 <- tibble(x = c(1:3, 3, 3)) #> df2 <- tibble(x = c(3:5, 5)) #>  #> intersect(df1, df2) #> union(df1, df2) #> setdiff(df1, df2) #> symdiff(df1, df2) #>   #> # Similar to head(mtcars, 1): #> mtcars %>% slice(1L) #> # Similar to tail(mtcars, 1): #> mtcars %>% slice(n()) #> mtcars %>% slice(5:n()) #> # Rows can be dropped with negative indices: #> slice(mtcars, -(1:4)) #>  #> # First and last rows based on existing order #> mtcars %>% slice_head(n = 5) #> mtcars %>% slice_tail(n = 5) #>  #> # Rows with minimum and maximum values of a variable #> mtcars %>% slice_min(mpg, n = 5) #> mtcars %>% slice_max(mpg, n = 5) #>  #> # slice_min() and slice_max() may return more rows than requested #> # in the presence of ties. #> mtcars %>% slice_min(cyl, n = 1) #> # Use with_ties = FALSE to return exactly n matches #> mtcars %>% slice_min(cyl, n = 1, with_ties = FALSE) #> # Or use additional variables to break the tie: #> mtcars %>% slice_min(tibble(cyl, mpg), n = 1) #>  #> # slice_sample() allows you to random select with or without replacement #> mtcars %>% slice_sample(n = 5) #> mtcars %>% slice_sample(n = 5, replace = TRUE) #>  #> # you can optionally weight by a variable - this code weights by the #> # physical weight of the cars, so heavy cars are more likely to get #> # selected #> mtcars %>% slice_sample(weight_by = wt, n = 5) #>  #> # Group wise operation ---------------------------------------- #> df <- tibble( #>   group = rep(c(\"a\", \"b\", \"c\"), c(1, 2, 4)), #>   x = runif(7) #> ) #>  #> # All slice helpers operate per group, silently truncating to the group #> # size, so the following code works without error #> df %>% group_by(group) %>% slice_head(n = 2) #>  #> # When specifying the proportion of rows to include non-integer sizes #> # are rounded down, so group a gets 0 rows #> df %>% group_by(group) %>% slice_head(prop = 0.5) #>  #> # Filter equivalents -------------------------------------------- #> # slice() expressions can often be written to use `filter()` and #> # `row_number()`, which can also be translated to SQL. For many databases, #> # you'll need to supply an explicit variable to use to compute the row number. #> filter(mtcars, row_number() == 1L) #> filter(mtcars, row_number() == n()) #> filter(mtcars, between(row_number(), 5, n())) #>  NULL NULL  #> \\dontshow{if (requireNamespace(\"dbplyr\", quietly = TRUE) && requireNamespace(\"RSQLite\", quietly = TRUE)) (if (getRversion() >= \"3.4\") withAutoprint else force)({ # examplesIf} #> con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") #> copy_to(con, mtcars) #>  #> # To retrieve a single table from a source, use `tbl()` #> mtcars <- con %>% tbl(\"mtcars\") #> mtcars #>  #> # You can also use pass raw SQL if you want a more sophisticated query #> con %>% tbl(sql(\"SELECT * FROM mtcars WHERE cyl == 8\")) #> \\dontshow{}) # examplesIf} #>  NULL NULL  #> starwars #>   #> storms #>  #> # Show a few recent storm paths #> if (requireNamespace(\"ggplot2\", quietly = TRUE)) { #>   library(ggplot2) #>   storms %>% #>     filter(year >= 2000) %>% #>     ggplot(aes(long, lat, color = paste(year, name))) + #>     geom_path(show.legend = FALSE) + #>     facet_wrap(~year) #> } #>  #> storms #>   #> # A summary applied to ungrouped tbl returns a single row #> mtcars %>% #>   summarise(mean = mean(disp), n = n()) #>  #> # Usually, you'll want to group first #> mtcars %>% #>   group_by(cyl) %>% #>   summarise(mean = mean(disp), n = n()) #>  #> # Each summary call removes one grouping level (since that group #> # is now just a single row) #> mtcars %>% #>   group_by(cyl, vs) %>% #>   summarise(cyl_n = n()) %>% #>   group_vars() #>  #> # BEWARE: reusing variables may lead to unexpected results #> mtcars %>% #>   group_by(cyl) %>% #>   summarise(disp = mean(disp), sd = sd(disp)) #>  #> # Refer to column names stored as strings with the `.data` pronoun: #> var <- \"mass\" #> summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE)) #> # Learn more in ?rlang::args_data_masking #>  #> # In dplyr 1.1.0, returning multiple rows per group was deprecated in favor #> # of `reframe()`, which never messages and always returns an ungrouped #> # result: #> mtcars %>% #>    group_by(cyl) %>% #>    summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75)) #> # -> #> mtcars %>% #>    group_by(cyl) %>% #>    reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75)) #>   #> # The _at() variants directly support strings: #> starwars %>% #>   summarise_at(c(\"height\", \"mass\"), mean, na.rm = TRUE) #> # -> #> starwars %>% summarise(across(c(\"height\", \"mass\"), ~ mean(.x, na.rm = TRUE))) #>  #> # You can also supply selection helpers to _at() functions but you have #> # to quote them with vars(): #> starwars %>% #>   summarise_at(vars(height:mass), mean, na.rm = TRUE) #> # -> #> starwars %>% #>   summarise(across(height:mass, ~ mean(.x, na.rm = TRUE))) #>  #> # The _if() variants apply a predicate function (a function that #> # returns TRUE or FALSE) to determine the relevant subset of #> # columns. Here we apply mean() to the numeric columns: #> starwars %>% #>   summarise_if(is.numeric, mean, na.rm = TRUE) #> starwars %>% #>   summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) #>  #> by_species <- iris %>% #>   group_by(Species) #>  #> # If you want to apply multiple transformations, pass a list of #> # functions. When there are multiple functions, they create new #> # variables instead of modifying the variables in place: #> by_species %>% #>   summarise_all(list(min, max)) #> # -> #> by_species %>% #>   summarise(across(everything(), list(min = min, max = max))) #>  NULL NULL NULL NULL NULL NULL  #> df <- data.frame(x = c(6, 4, 1, 10, 3, 1, 1)) #>  #> df %>% top_n(2)  # highest values #> df %>% top_n(-2) # lowest values #> # now use #> df %>% slice_max(x, n = 2) #> df %>% slice_min(x, n = 2) #>  #> # top_frac() -> prop argument of slice_min()/slice_max() #> df %>% top_frac(.5) #> # -> #> df %>% slice_max(x, prop = 0.5) #>  NULL NULL  #> df <- tibble(g = c(1, 1, 2, 2, 3), x = runif(5)) #>  #> # Old #> df %>% #>   with_groups(g, mutate, x_mean = mean(x)) #> # New #> df %>% mutate(x_mean = mean(x), .by = g) #>  NULL if (FALSE) { forgot_exmpls(\"dplyr\", \"count\", write = TRUE) }"},{"path":"https://parmsam.github.io/forgot/reference/forgot_fx.html","id":null,"dir":"Reference","previous_headings":"","what":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","title":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","text":"Get tibble roxygen2 fields specific function interest","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_fx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","text":"","code":"forgot_fx(pkg, function_name, field = NULL, print = TRUE)"},{"path":"https://parmsam.github.io/forgot/reference/forgot_fx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","text":"pkg string installed R package name function_name string function name R package field string roxygen2 field interest, NULL default print logical print data frame, TRUE default","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_fx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","text":"forgot tibble roxygen2 field info pkg function","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_fx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get tibble with roxygen2 fields for a specific function of interest — forgot_fx","text":"","code":"forgot_fx(\"dplyr\", \"count\", \"usage\", print = FALSE) forgot_fx(dplyr, \"count\", \"usage\", print = TRUE) #> # A tibble: 1 × 1 #>   usage                                                                          #>   <chr>                                                                          #> 1 \"\\ncount(x, ..., wt = NULL, sort = FALSE, name = NULL)\\n\\n\\\\method{countdata.… forgot_fx(\"dplyr\", \"count\", \"usage\", print = TRUE) #> # A tibble: 1 × 1 #>   usage                                                                          #>   <chr>                                                                          #> 1 \"\\ncount(x, ..., wt = NULL, sort = FALSE, name = NULL)\\n\\n\\\\method{countdata.…"},{"path":"https://parmsam.github.io/forgot/reference/forgot_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Print parameters for an R function of interest in console — forgot_params","title":"Print parameters for an R function of interest in console — forgot_params","text":"Print parameters R function interest console","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print parameters for an R function of interest in console — forgot_params","text":"","code":"forgot_params(pkg, function_name, write = FALSE)"},{"path":"https://parmsam.github.io/forgot/reference/forgot_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print parameters for an R function of interest in console — forgot_params","text":"pkg string installed R package name function_name function name R package write logical write RStudio rmd file, FALSE default","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_params.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print parameters for an R function of interest in console — forgot_params","text":"","code":"forgot_params(\"dplyr\", \"count\") #> x A data frame, data frame extension (e.g. a tibble), or a #> lazy data frame (e.g. from dbplyr or dtplyr). #> ------ #> ... <\\code{\\link[rlang:args_data_masking]{data-masking}}> Variables to group #> by. #> ------ #> wt <\\code{\\link[rlang:args_data_masking]{data-masking}}> Frequency weights. #> Can be \\code{NULL} or a variable: #> \\itemize{ #> \\item If \\code{NULL} (the default), counts the number of rows in each group. #> \\item If a variable, computes \\code{sum(wt)} for each group. #> } #> ------ #> sort If \\code{TRUE}, will show the largest groups at the top. #> ------ #> name The name of the new column in the output. #>  #> If omitted, it will default to \\code{n}. If there's already a column called \\code{n}, #> it will use \\code{nn}. If there's a column called \\code{n} and \\code{nn}, it'll use #> \\code{nnn}, and so on, adding \\code{n}s until it gets a new name. #> ------ #> .drop Handling of factor levels that don't appear in the data, passed #> on to \\code{\\link[=group_by]{group_by()}}. #>  #> For \\code{count()}: if \\code{FALSE} will include counts for empty groups (i.e. for #> levels of factors that don't exist in the data). #>  #> \\ifelse{html\\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated\\figure{lifecycle-deprecated.svgoptions: alt='[Deprecated]'}}\\strong{[Deprecated]}} For \\code{add_count()}: deprecated since it #> can't actually affect the output. forgot_params(dplyr, count) #> x A data frame, data frame extension (e.g. a tibble), or a #> lazy data frame (e.g. from dbplyr or dtplyr). #> ------ #> ... <\\code{\\link[rlang:args_data_masking]{data-masking}}> Variables to group #> by. #> ------ #> wt <\\code{\\link[rlang:args_data_masking]{data-masking}}> Frequency weights. #> Can be \\code{NULL} or a variable: #> \\itemize{ #> \\item If \\code{NULL} (the default), counts the number of rows in each group. #> \\item If a variable, computes \\code{sum(wt)} for each group. #> } #> ------ #> sort If \\code{TRUE}, will show the largest groups at the top. #> ------ #> name The name of the new column in the output. #>  #> If omitted, it will default to \\code{n}. If there's already a column called \\code{n}, #> it will use \\code{nn}. If there's a column called \\code{n} and \\code{nn}, it'll use #> \\code{nnn}, and so on, adding \\code{n}s until it gets a new name. #> ------ #> .drop Handling of factor levels that don't appear in the data, passed #> on to \\code{\\link[=group_by]{group_by()}}. #>  #> For \\code{count()}: if \\code{FALSE} will include counts for empty groups (i.e. for #> levels of factors that don't exist in the data). #>  #> \\ifelse{html\\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated\\figure{lifecycle-deprecated.svgoptions: alt='[Deprecated]'}}\\strong{[Deprecated]}} For \\code{add_count()}: deprecated since it #> can't actually affect the output. if (FALSE) { forgot_params(dplyr, count, write = TRUE) }"},{"path":"https://parmsam.github.io/forgot/reference/forgot_usg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print usage for an R function of interest in console — forgot_usg","title":"Print usage for an R function of interest in console — forgot_usg","text":"Print usage R function interest console","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_usg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print usage for an R function of interest in console — forgot_usg","text":"","code":"forgot_usg(pkg, function_name, write = FALSE)"},{"path":"https://parmsam.github.io/forgot/reference/forgot_usg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print usage for an R function of interest in console — forgot_usg","text":"pkg string installed R package name function_name function name R package write logical write RStudio rmd file, FALSE default","code":""},{"path":"https://parmsam.github.io/forgot/reference/forgot_usg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print usage for an R function of interest in console — forgot_usg","text":"","code":"forgot_usg(\"dplyr\", \"count\") #>  #> across(.cols, .fns, ..., .names = NULL, .unpack = FALSE) #>  #> if_any(.cols, .fns, ..., .names = NULL) #>  #> if_all(.cols, .fns, ..., .names = NULL) #>   #> add_rownames(df, var = \"rowname\") #>   #> all_equal( #>   target, #>   current, #>   ignore_col_order = TRUE, #>   ignore_row_order = TRUE, #>   convert = FALSE, #>   ... #> ) #>   #> all_vars(expr) #>  #> any_vars(expr) #>  NULL  #> arrange(.data, ..., .by_group = FALSE) #>  #> \\method{arrangedata.frame}(.data, ..., .by_group = FALSE, .locale = NULL) #>   #> arrange_all(.tbl, .funs = list(), ..., .by_group = FALSE, .locale = NULL) #>  #> arrange_at(.tbl, .vars, .funs = list(), ..., .by_group = FALSE, .locale = NULL) #>  #> arrange_if( #>   .tbl, #>   .predicate, #>   .funs = list(), #>   ..., #>   .by_group = FALSE, #>   .locale = NULL #> ) #>   #> auto_copy(x, y, copy = FALSE, ...) #>   #> db_desc(x) #>  #> sql_translate_env(con) #>  #> db_list_tables(con) #>  #> db_has_table(con, table) #>  #> db_data_type(con, fields) #>  #> db_save_query(con, sql, name, temporary = TRUE, ...) #>  #> db_begin(con, ...) #>  #> db_commit(con, ...) #>  #> db_rollback(con, ...) #>  #> db_write_table(con, table, types, values, temporary = FALSE, ...) #>  #> db_create_table(con, table, types, temporary = FALSE, ...) #>  #> db_insert_into(con, table, values, ...) #>  #> db_create_indexes(con, table, indexes = NULL, unique = FALSE, ...) #>  #> db_create_index(con, table, columns, name = NULL, unique = FALSE, ...) #>  #> db_drop_table(con, table, force = FALSE, ...) #>  #> db_analyze(con, table, ...) #>  #> db_explain(con, sql, ...) #>  #> db_query_fields(con, sql, ...) #>  #> db_query_rows(con, sql, ...) #>  #> sql_select( #>   con, #>   select, #>   from, #>   where = NULL, #>   group_by = NULL, #>   having = NULL, #>   order_by = NULL, #>   limit = NULL, #>   distinct = FALSE, #>   ... #> ) #>  #> sql_subquery(con, from, name = random_table_name(), ...) #>  #> sql_join(con, x, y, vars, type = \"inner\", by = NULL, ...) #>  #> sql_semi_join(con, x, y, anti = FALSE, by = NULL, ...) #>  #> sql_set_op(con, x, y, method) #>  #> sql_escape_string(con, x) #>  #> sql_escape_ident(con, x) #>   #> band_members #>  #> band_instruments #>  #> band_instruments2 #>   #> between(x, left, right) #>   #> bind_cols( #>   ..., #>   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") #> ) #>   #> bind_rows(..., .id = NULL) #>   #> c_across(cols) #>   #> case_match(.x, ..., .default = NULL, .ptype = NULL) #>   #> case_when(..., .default = NULL, .ptype = NULL, .size = NULL) #>   #> check_dbplyr() #>  #> wrap_dbplyr_obj(obj_name) #>   #> coalesce(..., .ptype = NULL, .size = NULL) #>   #> combine(...) #>   #> common_by(by = NULL, x, y) #>   #> compute(x, ...) #>  #> collect(x, ...) #>  #> collapse(x, ...) #>   #> consecutive_id(...) #>   #> n() #>  #> cur_group() #>  #> cur_group_id() #>  #> cur_group_rows() #>  #> cur_column() #>   #> copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...) #>   #> count(x, ..., wt = NULL, sort = FALSE, name = NULL) #>  #> \\method{countdata.frame}( #>   x, #>   ..., #>   wt = NULL, #>   sort = FALSE, #>   name = NULL, #>   .drop = group_by_drop_default(x) #> ) #>  #> tally(x, wt = NULL, sort = FALSE, name = NULL) #>  #> add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated()) #>  #> add_tally(x, wt = NULL, sort = FALSE, name = NULL) #>   #> cross_join(x, y, ..., copy = FALSE, suffix = c(\".x\", \".y\")) #>   #> cumall(x) #>  #> cumany(x) #>  #> cummean(x) #>   #> # Deprecated in 0.5.0 ------------------------------------- #>  #> id(.variables, drop = FALSE) #>  #> # Deprecated in 0.7.0 ------------------------------------- #>  #> failwith(default = NULL, f, quiet = FALSE) #>  #> # Deprecated in 0.8.* ------------------------------------- #>  #> select_vars(vars = chr(), ..., include = chr(), exclude = chr()) #>  #> rename_vars(vars = chr(), ..., strict = TRUE) #>  #> select_var(vars, var = -1) #>  #> current_vars(...) #>  #> # Deprecated in 1.0.0 ------------------------------------- #>  #> bench_tbls(tbls, op, ..., times = 10) #>  #> compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...) #>  #> compare_tbls2(tbls_x, tbls_y, op, ref = NULL, compare = equal_data_frame, ...) #>  #> eval_tbls(tbls, op) #>  #> eval_tbls2(tbls_x, tbls_y, op) #>  #> location(df) #>  #> changes(x, y) #>   #> cur_data() #>  #> cur_data_all() #>   #> desc(x) #>   #> dim_desc(x) #>   #> distinct(.data, ..., .keep_all = FALSE) #>   #> distinct_all(.tbl, .funs = list(), ..., .keep_all = FALSE) #>  #> distinct_at(.tbl, .vars, .funs = list(), ..., .keep_all = FALSE) #>  #> distinct_if(.tbl, .predicate, .funs = list(), ..., .keep_all = FALSE) #>   #> do(.data, ...) #>  NULL NULL NULL NULL  #> dplyr_row_slice(data, i, ...) #>  #> dplyr_col_modify(data, cols) #>  #> dplyr_reconstruct(data, template) #>  NULL  #> explain(x, ...) #>  #> show_query(x, ...) #>   #> semi_join(x, y, by = NULL, copy = FALSE, ...) #>  #> \\method{semi_joindata.frame}(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) #>  #> anti_join(x, y, by = NULL, copy = FALSE, ...) #>  #> \\method{anti_joindata.frame}(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) #>   #> filter(.data, ..., .by = NULL, .preserve = FALSE) #>   #> filter_all(.tbl, .vars_predicate, .preserve = FALSE) #>  #> filter_if(.tbl, .predicate, .vars_predicate, .preserve = FALSE) #>  #> filter_at(.tbl, .vars, .vars_predicate, .preserve = FALSE) #>   #> funs(..., .args = list()) #>  NULL  #> group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)) #>  #> ungroup(x, ...) #>   #> group_by_all( #>   .tbl, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>  #> group_by_at( #>   .tbl, #>   .vars, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>  #> group_by_if( #>   .tbl, #>   .predicate, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>   #> group_by_drop_default(.tbl) #>   #> distinct_prepare( #>   .data, #>   vars, #>   group_vars = character(), #>   .keep_all = FALSE, #>   caller_env = caller_env(2), #>   error_call = caller_env() #> ) #>  #> group_by_prepare( #>   .data, #>   ..., #>   .add = FALSE, #>   .dots = deprecated(), #>   add = deprecated(), #>   error_call = caller_env() #> ) #>   #> group_cols(vars = NULL, data = NULL) #>   #> group_data(.data) #>  #> group_keys(.tbl, ...) #>  #> group_rows(.data) #>  #> group_indices(.data, ...) #>  #> group_vars(x) #>  #> groups(x) #>  #> group_size(x) #>  #> n_groups(x) #>   #> group_map(.data, .f, ..., .keep = FALSE) #>  #> group_modify(.data, .f, ..., .keep = FALSE) #>  #> group_walk(.data, .f, ..., .keep = FALSE) #>   #> group_nest(.tbl, ..., .key = \"data\", keep = FALSE) #>   #> group_split(.tbl, ..., .keep = TRUE) #>   #> group_trim(.tbl, .drop = group_by_drop_default(.tbl)) #>   #> grouped_df(data, vars, drop = group_by_drop_default(data)) #>  #> is.grouped_df(x) #>  #> is_grouped_df(x) #>   #> ident(...) #>   #> if_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL) #>   #> join_by(...) #>   #> last_dplyr_warnings(n = 5) #>   #> lag(x, n = 1L, default = NULL, order_by = NULL, ...) #>  #> lead(x, n = 1L, default = NULL, order_by = NULL, ...) #>   #> make_tbl(subclass, ...) #>   #> inner_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{inner_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> left_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{left_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> right_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{right_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> full_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{full_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   relationship = NULL #> ) #>   #> mutate(.data, ...) #>  #> \\method{mutatedata.frame}( #>   .data, #>   ..., #>   .by = NULL, #>   .keep = c(\"all\", \"used\", \"unused\", \"none\"), #>   .before = NULL, #>   .after = NULL #> ) #>   #> mutate_all(.tbl, .funs, ...) #>  #> mutate_if(.tbl, .predicate, .funs, ...) #>  #> mutate_at(.tbl, .vars, .funs, ..., .cols = NULL) #>  #> transmute_all(.tbl, .funs, ...) #>  #> transmute_if(.tbl, .predicate, .funs, ...) #>  #> transmute_at(.tbl, .vars, .funs, ..., .cols = NULL) #>   #> n_distinct(..., na.rm = FALSE) #>   #> na_if(x, y) #>   #> near(x, y, tol = .Machine$double.eps^0.5) #>   #> nest_by(.data, ..., .key = \"data\", .keep = FALSE) #>   #> nest_join(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...) #>  #> \\method{nest_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   keep = NULL, #>   name = NULL, #>   ..., #>   na_matches = c(\"na\", \"never\"), #>   unmatched = \"drop\" #> ) #>   #> new_grouped_df(x, groups, ..., class = character()) #>  #> validate_grouped_df(x, check_bounds = FALSE) #>  #> new_rowwise_df(data, group_data = NULL, ..., class = character()) #>  #> validate_rowwise_df(x) #>   #> nth(x, n, order_by = NULL, default = NULL, na_rm = FALSE) #>  #> first(x, order_by = NULL, default = NULL, na_rm = FALSE) #>  #> last(x, order_by = NULL, default = NULL, na_rm = FALSE) #>   #> ntile(x = row_number(), n) #>   #> order_by(order_by, call) #>   #> percent_rank(x) #>  #> cume_dist(x) #>   #> pick(...) #>   #> progress_estimated(n, min_time = 0) #>   #> pull(.data, var = -1, name = NULL, ...) #>   #> recode(.x, ..., .default = NULL, .missing = NULL) #>  #> recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE) #>  NULL  #> reframe(.data, ..., .by = NULL) #>   #> relocate(.data, ..., .before = NULL, .after = NULL) #>   #> rename(.data, ...) #>  #> rename_with(.data, .fn, .cols = everything(), ...) #>   #> row_number(x) #>  #> min_rank(x) #>  #> dense_rank(x) #>   #> rows_insert( #>   x, #>   y, #>   by = NULL, #>   ..., #>   conflict = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_append(x, y, ..., copy = FALSE, in_place = FALSE) #>  #> rows_update( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_patch( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_upsert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE) #>  #> rows_delete( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>   #> rowwise(data, ...) #>   #> same_src(x, y) #>   #> sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...) #>  #> sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...) #>  NULL  #> add_count_(x, vars, wt = NULL, sort = FALSE) #>  #> add_tally_(x, wt, sort = FALSE) #>  #> arrange_(.data, ..., .dots = list()) #>  #> count_(x, vars, wt = NULL, sort = FALSE, .drop = group_by_drop_default(x)) #>  #> distinct_(.data, ..., .dots, .keep_all = FALSE) #>  #> do_(.data, ..., .dots = list()) #>  #> filter_(.data, ..., .dots = list()) #>  #> funs_(dots, args = list(), env = base_env()) #>  #> group_by_(.data, ..., .dots = list(), add = FALSE) #>  #> group_indices_(.data, ..., .dots = list()) #>  #> mutate_(.data, ..., .dots = list()) #>  #> tally_(x, wt, sort = FALSE) #>  #> transmute_(.data, ..., .dots = list()) #>  #> rename_(.data, ..., .dots = list()) #>  #> rename_vars_(vars, args) #>  #> select_(.data, ..., .dots = list()) #>  #> select_vars_(vars, args, include = chr(), exclude = chr()) #>  #> slice_(.data, ..., .dots = list()) #>  #> summarise_(.data, ..., .dots = list()) #>  #> summarize_(.data, ..., .dots = list()) #>   #> select(.data, ...) #>   #> select_all(.tbl, .funs = list(), ...) #>  #> rename_all(.tbl, .funs = list(), ...) #>  #> select_if(.tbl, .predicate, .funs = list(), ...) #>  #> rename_if(.tbl, .predicate, .funs = list(), ...) #>  #> select_at(.tbl, .vars, .funs = list(), ...) #>  #> rename_at(.tbl, .vars, .funs = list(), ...) #>   #> intersect(x, y, ...) #>  #> union(x, y, ...) #>  #> union_all(x, y, ...) #>  #> setdiff(x, y, ...) #>  #> setequal(x, y, ...) #>  #> symdiff(x, y, ...) #>   #> slice(.data, ..., .by = NULL, .preserve = FALSE) #>  #> slice_head(.data, ..., n, prop, by = NULL) #>  #> slice_tail(.data, ..., n, prop, by = NULL) #>  #> slice_min( #>   .data, #>   order_by, #>   ..., #>   n, #>   prop, #>   by = NULL, #>   with_ties = TRUE, #>   na_rm = FALSE #> ) #>  #> slice_max( #>   .data, #>   order_by, #>   ..., #>   n, #>   prop, #>   by = NULL, #>   with_ties = TRUE, #>   na_rm = FALSE #> ) #>  #> slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE) #>   #> sql(...) #>   #> src(subclass, ...) #>  #> is.src(x) #>   #> src_mysql( #>   dbname, #>   host = NULL, #>   port = 0L, #>   username = \"root\", #>   password = \"\", #>   ... #> ) #>  #> src_postgres( #>   dbname = NULL, #>   host = NULL, #>   port = NULL, #>   user = NULL, #>   password = NULL, #>   ... #> ) #>  #> src_sqlite(path, create = FALSE) #>   #> src_local(tbl, pkg = NULL, env = NULL) #>  #> src_df(pkg = NULL, env = NULL) #>   #> src_tbls(x, ...) #>   #> starwars #>   #> storms #>   #> summarise(.data, ..., .by = NULL, .groups = NULL) #>  #> summarize(.data, ..., .by = NULL, .groups = NULL) #>   #> summarise_all(.tbl, .funs, ...) #>  #> summarise_if(.tbl, .predicate, .funs, ...) #>  #> summarise_at(.tbl, .vars, .funs, ..., .cols = NULL) #>  #> summarize_all(.tbl, .funs, ...) #>  #> summarize_if(.tbl, .predicate, .funs, ...) #>  #> summarize_at(.tbl, .vars, .funs, ..., .cols = NULL) #>   #> summarise_each(tbl, funs, ...) #>  #> summarise_each_(tbl, funs, vars) #>  #> mutate_each(tbl, funs, ...) #>  #> mutate_each_(tbl, funs, vars) #>  #> summarize_each(tbl, funs, ...) #>  #> summarize_each_(tbl, funs, vars) #>   #> tbl(src, ...) #>  #> is.tbl(x) #>   #> tbl_df(data) #>  #> as.tbl(x, ...) #>   #> tbl_ptype(.data) #>   #> tbl_vars(x) #>  #> tbl_nongroup_vars(x) #>  NULL  #> top_n(x, n, wt) #>  #> top_frac(x, n, wt) #>   #> transmute(.data, ...) #>   #> vars(...) #>   #> with_groups(.data, .groups, .f, ...) #>   #> with_order(order_by, fun, x, ...) forgot_usg(dplyr, count) #>  #> across(.cols, .fns, ..., .names = NULL, .unpack = FALSE) #>  #> if_any(.cols, .fns, ..., .names = NULL) #>  #> if_all(.cols, .fns, ..., .names = NULL) #>   #> add_rownames(df, var = \"rowname\") #>   #> all_equal( #>   target, #>   current, #>   ignore_col_order = TRUE, #>   ignore_row_order = TRUE, #>   convert = FALSE, #>   ... #> ) #>   #> all_vars(expr) #>  #> any_vars(expr) #>  NULL  #> arrange(.data, ..., .by_group = FALSE) #>  #> \\method{arrangedata.frame}(.data, ..., .by_group = FALSE, .locale = NULL) #>   #> arrange_all(.tbl, .funs = list(), ..., .by_group = FALSE, .locale = NULL) #>  #> arrange_at(.tbl, .vars, .funs = list(), ..., .by_group = FALSE, .locale = NULL) #>  #> arrange_if( #>   .tbl, #>   .predicate, #>   .funs = list(), #>   ..., #>   .by_group = FALSE, #>   .locale = NULL #> ) #>   #> auto_copy(x, y, copy = FALSE, ...) #>   #> db_desc(x) #>  #> sql_translate_env(con) #>  #> db_list_tables(con) #>  #> db_has_table(con, table) #>  #> db_data_type(con, fields) #>  #> db_save_query(con, sql, name, temporary = TRUE, ...) #>  #> db_begin(con, ...) #>  #> db_commit(con, ...) #>  #> db_rollback(con, ...) #>  #> db_write_table(con, table, types, values, temporary = FALSE, ...) #>  #> db_create_table(con, table, types, temporary = FALSE, ...) #>  #> db_insert_into(con, table, values, ...) #>  #> db_create_indexes(con, table, indexes = NULL, unique = FALSE, ...) #>  #> db_create_index(con, table, columns, name = NULL, unique = FALSE, ...) #>  #> db_drop_table(con, table, force = FALSE, ...) #>  #> db_analyze(con, table, ...) #>  #> db_explain(con, sql, ...) #>  #> db_query_fields(con, sql, ...) #>  #> db_query_rows(con, sql, ...) #>  #> sql_select( #>   con, #>   select, #>   from, #>   where = NULL, #>   group_by = NULL, #>   having = NULL, #>   order_by = NULL, #>   limit = NULL, #>   distinct = FALSE, #>   ... #> ) #>  #> sql_subquery(con, from, name = random_table_name(), ...) #>  #> sql_join(con, x, y, vars, type = \"inner\", by = NULL, ...) #>  #> sql_semi_join(con, x, y, anti = FALSE, by = NULL, ...) #>  #> sql_set_op(con, x, y, method) #>  #> sql_escape_string(con, x) #>  #> sql_escape_ident(con, x) #>   #> band_members #>  #> band_instruments #>  #> band_instruments2 #>   #> between(x, left, right) #>   #> bind_cols( #>   ..., #>   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") #> ) #>   #> bind_rows(..., .id = NULL) #>   #> c_across(cols) #>   #> case_match(.x, ..., .default = NULL, .ptype = NULL) #>   #> case_when(..., .default = NULL, .ptype = NULL, .size = NULL) #>   #> check_dbplyr() #>  #> wrap_dbplyr_obj(obj_name) #>   #> coalesce(..., .ptype = NULL, .size = NULL) #>   #> combine(...) #>   #> common_by(by = NULL, x, y) #>   #> compute(x, ...) #>  #> collect(x, ...) #>  #> collapse(x, ...) #>   #> consecutive_id(...) #>   #> n() #>  #> cur_group() #>  #> cur_group_id() #>  #> cur_group_rows() #>  #> cur_column() #>   #> copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...) #>   #> count(x, ..., wt = NULL, sort = FALSE, name = NULL) #>  #> \\method{countdata.frame}( #>   x, #>   ..., #>   wt = NULL, #>   sort = FALSE, #>   name = NULL, #>   .drop = group_by_drop_default(x) #> ) #>  #> tally(x, wt = NULL, sort = FALSE, name = NULL) #>  #> add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated()) #>  #> add_tally(x, wt = NULL, sort = FALSE, name = NULL) #>   #> cross_join(x, y, ..., copy = FALSE, suffix = c(\".x\", \".y\")) #>   #> cumall(x) #>  #> cumany(x) #>  #> cummean(x) #>   #> # Deprecated in 0.5.0 ------------------------------------- #>  #> id(.variables, drop = FALSE) #>  #> # Deprecated in 0.7.0 ------------------------------------- #>  #> failwith(default = NULL, f, quiet = FALSE) #>  #> # Deprecated in 0.8.* ------------------------------------- #>  #> select_vars(vars = chr(), ..., include = chr(), exclude = chr()) #>  #> rename_vars(vars = chr(), ..., strict = TRUE) #>  #> select_var(vars, var = -1) #>  #> current_vars(...) #>  #> # Deprecated in 1.0.0 ------------------------------------- #>  #> bench_tbls(tbls, op, ..., times = 10) #>  #> compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...) #>  #> compare_tbls2(tbls_x, tbls_y, op, ref = NULL, compare = equal_data_frame, ...) #>  #> eval_tbls(tbls, op) #>  #> eval_tbls2(tbls_x, tbls_y, op) #>  #> location(df) #>  #> changes(x, y) #>   #> cur_data() #>  #> cur_data_all() #>   #> desc(x) #>   #> dim_desc(x) #>   #> distinct(.data, ..., .keep_all = FALSE) #>   #> distinct_all(.tbl, .funs = list(), ..., .keep_all = FALSE) #>  #> distinct_at(.tbl, .vars, .funs = list(), ..., .keep_all = FALSE) #>  #> distinct_if(.tbl, .predicate, .funs = list(), ..., .keep_all = FALSE) #>   #> do(.data, ...) #>  NULL NULL NULL NULL  #> dplyr_row_slice(data, i, ...) #>  #> dplyr_col_modify(data, cols) #>  #> dplyr_reconstruct(data, template) #>  NULL  #> explain(x, ...) #>  #> show_query(x, ...) #>   #> semi_join(x, y, by = NULL, copy = FALSE, ...) #>  #> \\method{semi_joindata.frame}(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) #>  #> anti_join(x, y, by = NULL, copy = FALSE, ...) #>  #> \\method{anti_joindata.frame}(x, y, by = NULL, copy = FALSE, ..., na_matches = c(\"na\", \"never\")) #>   #> filter(.data, ..., .by = NULL, .preserve = FALSE) #>   #> filter_all(.tbl, .vars_predicate, .preserve = FALSE) #>  #> filter_if(.tbl, .predicate, .vars_predicate, .preserve = FALSE) #>  #> filter_at(.tbl, .vars, .vars_predicate, .preserve = FALSE) #>   #> funs(..., .args = list()) #>  NULL  #> group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)) #>  #> ungroup(x, ...) #>   #> group_by_all( #>   .tbl, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>  #> group_by_at( #>   .tbl, #>   .vars, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>  #> group_by_if( #>   .tbl, #>   .predicate, #>   .funs = list(), #>   ..., #>   .add = FALSE, #>   .drop = group_by_drop_default(.tbl) #> ) #>   #> group_by_drop_default(.tbl) #>   #> distinct_prepare( #>   .data, #>   vars, #>   group_vars = character(), #>   .keep_all = FALSE, #>   caller_env = caller_env(2), #>   error_call = caller_env() #> ) #>  #> group_by_prepare( #>   .data, #>   ..., #>   .add = FALSE, #>   .dots = deprecated(), #>   add = deprecated(), #>   error_call = caller_env() #> ) #>   #> group_cols(vars = NULL, data = NULL) #>   #> group_data(.data) #>  #> group_keys(.tbl, ...) #>  #> group_rows(.data) #>  #> group_indices(.data, ...) #>  #> group_vars(x) #>  #> groups(x) #>  #> group_size(x) #>  #> n_groups(x) #>   #> group_map(.data, .f, ..., .keep = FALSE) #>  #> group_modify(.data, .f, ..., .keep = FALSE) #>  #> group_walk(.data, .f, ..., .keep = FALSE) #>   #> group_nest(.tbl, ..., .key = \"data\", keep = FALSE) #>   #> group_split(.tbl, ..., .keep = TRUE) #>   #> group_trim(.tbl, .drop = group_by_drop_default(.tbl)) #>   #> grouped_df(data, vars, drop = group_by_drop_default(data)) #>  #> is.grouped_df(x) #>  #> is_grouped_df(x) #>   #> ident(...) #>   #> if_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL) #>   #> join_by(...) #>   #> last_dplyr_warnings(n = 5) #>   #> lag(x, n = 1L, default = NULL, order_by = NULL, ...) #>  #> lead(x, n = 1L, default = NULL, order_by = NULL, ...) #>   #> make_tbl(subclass, ...) #>   #> inner_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{inner_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> left_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{left_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> right_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{right_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   unmatched = \"drop\", #>   relationship = NULL #> ) #>  #> full_join( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL #> ) #>  #> \\method{full_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   suffix = c(\".x\", \".y\"), #>   ..., #>   keep = NULL, #>   na_matches = c(\"na\", \"never\"), #>   multiple = \"all\", #>   relationship = NULL #> ) #>   #> mutate(.data, ...) #>  #> \\method{mutatedata.frame}( #>   .data, #>   ..., #>   .by = NULL, #>   .keep = c(\"all\", \"used\", \"unused\", \"none\"), #>   .before = NULL, #>   .after = NULL #> ) #>   #> mutate_all(.tbl, .funs, ...) #>  #> mutate_if(.tbl, .predicate, .funs, ...) #>  #> mutate_at(.tbl, .vars, .funs, ..., .cols = NULL) #>  #> transmute_all(.tbl, .funs, ...) #>  #> transmute_if(.tbl, .predicate, .funs, ...) #>  #> transmute_at(.tbl, .vars, .funs, ..., .cols = NULL) #>   #> n_distinct(..., na.rm = FALSE) #>   #> na_if(x, y) #>   #> near(x, y, tol = .Machine$double.eps^0.5) #>   #> nest_by(.data, ..., .key = \"data\", .keep = FALSE) #>   #> nest_join(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...) #>  #> \\method{nest_joindata.frame}( #>   x, #>   y, #>   by = NULL, #>   copy = FALSE, #>   keep = NULL, #>   name = NULL, #>   ..., #>   na_matches = c(\"na\", \"never\"), #>   unmatched = \"drop\" #> ) #>   #> new_grouped_df(x, groups, ..., class = character()) #>  #> validate_grouped_df(x, check_bounds = FALSE) #>  #> new_rowwise_df(data, group_data = NULL, ..., class = character()) #>  #> validate_rowwise_df(x) #>   #> nth(x, n, order_by = NULL, default = NULL, na_rm = FALSE) #>  #> first(x, order_by = NULL, default = NULL, na_rm = FALSE) #>  #> last(x, order_by = NULL, default = NULL, na_rm = FALSE) #>   #> ntile(x = row_number(), n) #>   #> order_by(order_by, call) #>   #> percent_rank(x) #>  #> cume_dist(x) #>   #> pick(...) #>   #> progress_estimated(n, min_time = 0) #>   #> pull(.data, var = -1, name = NULL, ...) #>   #> recode(.x, ..., .default = NULL, .missing = NULL) #>  #> recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE) #>  NULL  #> reframe(.data, ..., .by = NULL) #>   #> relocate(.data, ..., .before = NULL, .after = NULL) #>   #> rename(.data, ...) #>  #> rename_with(.data, .fn, .cols = everything(), ...) #>   #> row_number(x) #>  #> min_rank(x) #>  #> dense_rank(x) #>   #> rows_insert( #>   x, #>   y, #>   by = NULL, #>   ..., #>   conflict = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_append(x, y, ..., copy = FALSE, in_place = FALSE) #>  #> rows_update( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_patch( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>  #> rows_upsert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE) #>  #> rows_delete( #>   x, #>   y, #>   by = NULL, #>   ..., #>   unmatched = c(\"error\", \"ignore\"), #>   copy = FALSE, #>   in_place = FALSE #> ) #>   #> rowwise(data, ...) #>   #> same_src(x, y) #>   #> sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...) #>  #> sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...) #>  NULL  #> add_count_(x, vars, wt = NULL, sort = FALSE) #>  #> add_tally_(x, wt, sort = FALSE) #>  #> arrange_(.data, ..., .dots = list()) #>  #> count_(x, vars, wt = NULL, sort = FALSE, .drop = group_by_drop_default(x)) #>  #> distinct_(.data, ..., .dots, .keep_all = FALSE) #>  #> do_(.data, ..., .dots = list()) #>  #> filter_(.data, ..., .dots = list()) #>  #> funs_(dots, args = list(), env = base_env()) #>  #> group_by_(.data, ..., .dots = list(), add = FALSE) #>  #> group_indices_(.data, ..., .dots = list()) #>  #> mutate_(.data, ..., .dots = list()) #>  #> tally_(x, wt, sort = FALSE) #>  #> transmute_(.data, ..., .dots = list()) #>  #> rename_(.data, ..., .dots = list()) #>  #> rename_vars_(vars, args) #>  #> select_(.data, ..., .dots = list()) #>  #> select_vars_(vars, args, include = chr(), exclude = chr()) #>  #> slice_(.data, ..., .dots = list()) #>  #> summarise_(.data, ..., .dots = list()) #>  #> summarize_(.data, ..., .dots = list()) #>   #> select(.data, ...) #>   #> select_all(.tbl, .funs = list(), ...) #>  #> rename_all(.tbl, .funs = list(), ...) #>  #> select_if(.tbl, .predicate, .funs = list(), ...) #>  #> rename_if(.tbl, .predicate, .funs = list(), ...) #>  #> select_at(.tbl, .vars, .funs = list(), ...) #>  #> rename_at(.tbl, .vars, .funs = list(), ...) #>   #> intersect(x, y, ...) #>  #> union(x, y, ...) #>  #> union_all(x, y, ...) #>  #> setdiff(x, y, ...) #>  #> setequal(x, y, ...) #>  #> symdiff(x, y, ...) #>   #> slice(.data, ..., .by = NULL, .preserve = FALSE) #>  #> slice_head(.data, ..., n, prop, by = NULL) #>  #> slice_tail(.data, ..., n, prop, by = NULL) #>  #> slice_min( #>   .data, #>   order_by, #>   ..., #>   n, #>   prop, #>   by = NULL, #>   with_ties = TRUE, #>   na_rm = FALSE #> ) #>  #> slice_max( #>   .data, #>   order_by, #>   ..., #>   n, #>   prop, #>   by = NULL, #>   with_ties = TRUE, #>   na_rm = FALSE #> ) #>  #> slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE) #>   #> sql(...) #>   #> src(subclass, ...) #>  #> is.src(x) #>   #> src_mysql( #>   dbname, #>   host = NULL, #>   port = 0L, #>   username = \"root\", #>   password = \"\", #>   ... #> ) #>  #> src_postgres( #>   dbname = NULL, #>   host = NULL, #>   port = NULL, #>   user = NULL, #>   password = NULL, #>   ... #> ) #>  #> src_sqlite(path, create = FALSE) #>   #> src_local(tbl, pkg = NULL, env = NULL) #>  #> src_df(pkg = NULL, env = NULL) #>   #> src_tbls(x, ...) #>   #> starwars #>   #> storms #>   #> summarise(.data, ..., .by = NULL, .groups = NULL) #>  #> summarize(.data, ..., .by = NULL, .groups = NULL) #>   #> summarise_all(.tbl, .funs, ...) #>  #> summarise_if(.tbl, .predicate, .funs, ...) #>  #> summarise_at(.tbl, .vars, .funs, ..., .cols = NULL) #>  #> summarize_all(.tbl, .funs, ...) #>  #> summarize_if(.tbl, .predicate, .funs, ...) #>  #> summarize_at(.tbl, .vars, .funs, ..., .cols = NULL) #>   #> summarise_each(tbl, funs, ...) #>  #> summarise_each_(tbl, funs, vars) #>  #> mutate_each(tbl, funs, ...) #>  #> mutate_each_(tbl, funs, vars) #>  #> summarize_each(tbl, funs, ...) #>  #> summarize_each_(tbl, funs, vars) #>   #> tbl(src, ...) #>  #> is.tbl(x) #>   #> tbl_df(data) #>  #> as.tbl(x, ...) #>   #> tbl_ptype(.data) #>   #> tbl_vars(x) #>  #> tbl_nongroup_vars(x) #>  NULL  #> top_n(x, n, wt) #>  #> top_frac(x, n, wt) #>   #> transmute(.data, ...) #>   #> vars(...) #>   #> with_groups(.data, .groups, .f, ...) #>   #> with_order(order_by, fun, x, ...) if (FALSE) { forgot_usg(dplyr, count, write = TRUE) }"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://parmsam.github.io/forgot/reference/new_file_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Create new RStudio Rmarkdown document with content of interest — new_file_write","title":"Create new RStudio Rmarkdown document with content of interest — new_file_write","text":"Create new RStudio Rmarkdown document content interest","code":""},{"path":"https://parmsam.github.io/forgot/reference/new_file_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create new RStudio Rmarkdown document with content of interest — new_file_write","text":"","code":"new_file_write(content, type = \"rmarkdown\")"},{"path":"https://parmsam.github.io/forgot/reference/new_file_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create new RStudio Rmarkdown document with content of interest — new_file_write","text":"content vector text include file type type file create RStudio IDE, RMarkdown default","code":""},{"path":"https://parmsam.github.io/forgot/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://parmsam.github.io/forgot/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://parmsam.github.io/forgot/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://parmsam.github.io/forgot/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_html_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Get simple reactable HTML table — simple_html_table","title":"Get simple reactable HTML table — simple_html_table","text":"Get simple reactable HTML table","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_html_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get simple reactable HTML table — simple_html_table","text":"","code":"simple_html_table(data)"},{"path":"https://parmsam.github.io/forgot/reference/simple_html_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get simple reactable HTML table — simple_html_table","text":"data tibble dataset reactable","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_html_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get simple reactable HTML table — simple_html_table","text":"reactable HTML object","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_html_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get simple reactable HTML table — simple_html_table","text":"","code":"simple_html_table(iris)      {\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"Sepal.Length\":[5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9,5.4,4.8,4.8,4.3,5.8,5.7,5.4,5.1,5.7,5.1,5.4,5.1,4.6,5.1,4.8,5,5,5.2,5.2,4.7,4.8,5.4,5.2,5.5,4.9,5,5.5,4.9,4.4,5.1,5,4.5,4.4,5,5.1,4.8,5.1,4.6,5.3,5,7,6.4,6.9,5.5,6.5,5.7,6.3,4.9,6.6,5.2,5,5.9,6,6.1,5.6,6.7,5.6,5.8,6.2,5.6,5.9,6.1,6.3,6.1,6.4,6.6,6.8,6.7,6,5.7,5.5,5.5,5.8,6,5.4,6,6.7,6.3,5.6,5.5,5.5,6.1,5.8,5,5.6,5.7,5.7,6.2,5.1,5.7,6.3,5.8,7.1,6.3,6.5,7.6,4.9,7.3,6.7,7.2,6.5,6.4,6.8,5.7,5.8,6.4,6.5,7.7,7.7,6,6.9,5.6,7.7,6.3,6.7,7.2,6.2,6.1,6.4,7.2,7.4,7.9,6.4,6.3,6.1,7.7,6.3,6.4,6,6.9,6.7,6.9,5.8,6.8,6.7,6.7,6.3,6.5,6.2,5.9],\"Sepal.Width\":[3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1,3.7,3.4,3,3,4,4.4,3.9,3.5,3.8,3.8,3.4,3.7,3.6,3.3,3.4,3,3.4,3.5,3.4,3.2,3.1,3.4,4.1,4.2,3.1,3.2,3.5,3.6,3,3.4,3.5,2.3,3.2,3.5,3.8,3,3.8,3.2,3.7,3.3,3.2,3.2,3.1,2.3,2.8,2.8,3.3,2.4,2.9,2.7,2,3,2.2,2.9,2.9,3.1,3,2.7,2.2,2.5,3.2,2.8,2.5,2.8,2.9,3,2.8,3,2.9,2.6,2.4,2.4,2.7,2.7,3,3.4,3.1,2.3,3,2.5,2.6,3,2.6,2.3,2.7,3,2.9,2.9,2.5,2.8,3.3,2.7,3,2.9,3,3,2.5,2.9,2.5,3.6,3.2,2.7,3,2.5,2.8,3.2,3,3.8,2.6,2.2,3.2,2.8,2.8,2.7,3.3,3.2,2.8,3,2.8,3,2.8,3.8,2.8,2.8,2.6,3,3.4,3.1,3,3.1,3.1,3.1,2.7,3.2,3.3,3,2.5,3,3.4,3],\"Petal.Length\":[1.4,1.4,1.3,1.5,1.4,1.7,1.4,1.5,1.4,1.5,1.5,1.6,1.4,1.1,1.2,1.5,1.3,1.4,1.7,1.5,1.7,1.5,1,1.7,1.9,1.6,1.6,1.5,1.4,1.6,1.6,1.5,1.5,1.4,1.5,1.2,1.3,1.4,1.3,1.5,1.3,1.3,1.3,1.6,1.9,1.4,1.6,1.4,1.5,1.4,4.7,4.5,4.9,4,4.6,4.5,4.7,3.3,4.6,3.9,3.5,4.2,4,4.7,3.6,4.4,4.5,4.1,4.5,3.9,4.8,4,4.9,4.7,4.3,4.4,4.8,5,4.5,3.5,3.8,3.7,3.9,5.1,4.5,4.5,4.7,4.4,4.1,4,4.4,4.6,4,3.3,4.2,4.2,4.2,4.3,3,4.1,6,5.1,5.9,5.6,5.8,6.6,4.5,6.3,5.8,6.1,5.1,5.3,5.5,5,5.1,5.3,5.5,6.7,6.9,5,5.7,4.9,6.7,4.9,5.7,6,4.8,4.9,5.6,5.8,6.1,6.4,5.6,5.1,5.6,6.1,5.6,5.5,4.8,5.4,5.6,5.1,5.1,5.9,5.7,5.2,5,5.2,5.4,5.1],\"Petal.Width\":[0.2,0.2,0.2,0.2,0.2,0.4,0.3,0.2,0.2,0.1,0.2,0.2,0.1,0.1,0.2,0.4,0.4,0.3,0.3,0.3,0.2,0.4,0.2,0.5,0.2,0.2,0.4,0.2,0.2,0.2,0.2,0.4,0.1,0.2,0.2,0.2,0.2,0.1,0.2,0.2,0.3,0.3,0.2,0.6,0.4,0.3,0.2,0.2,0.2,0.2,1.4,1.5,1.5,1.3,1.5,1.3,1.6,1,1.3,1.4,1,1.5,1,1.4,1.3,1.4,1.5,1,1.5,1.1,1.8,1.3,1.5,1.2,1.3,1.4,1.4,1.7,1.5,1,1.1,1,1.2,1.6,1.5,1.6,1.5,1.3,1.3,1.3,1.2,1.4,1.2,1,1.3,1.2,1.3,1.3,1.1,1.3,2.5,1.9,2.1,1.8,2.2,2.1,1.7,1.8,1.8,2.5,2,1.9,2.1,2,2.4,2.3,1.8,2.2,2.3,1.5,2.3,2,2,1.8,2.1,1.8,1.8,1.8,2.1,1.6,1.9,2,2.2,1.5,1.4,2.3,2.4,1.8,1.8,2.1,2.4,2.3,1.9,2.3,2.5,2.3,1.9,2,2.3,1.8],\"Species\":[\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\"]},\"columns\":[{\"id\":\"Sepal.Length\",\"name\":\"Sepal.Length\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Sepal.Width\",\"name\":\"Sepal.Width\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Petal.Length\",\"name\":\"Petal.Length\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Petal.Width\",\"name\":\"Petal.Width\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Species\",\"name\":\"Species\",\"type\":\"factor\",\"minWidth\":120}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":4,\"showPageSizeOptions\":true,\"pageSizeOptions\":[4,8,12],\"highlight\":true,\"bordered\":true,\"nowrap\":true,\"dataKey\":\"3f7bb21cea252c825589d9fb005a0c99\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://parmsam.github.io/forgot/reference/simple_reactable_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Get simple reactable table — simple_reactable_table","title":"Get simple reactable table — simple_reactable_table","text":"Get simple reactable table","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_reactable_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get simple reactable table — simple_reactable_table","text":"","code":"simple_reactable_table(data, shiny_vers = F)"},{"path":"https://parmsam.github.io/forgot/reference/simple_reactable_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get simple reactable table — simple_reactable_table","text":"data tibble dataset shiny_vers option return shiny version used `simple_html_table()`","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_reactable_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get simple reactable table — simple_reactable_table","text":"reactable object","code":""},{"path":"https://parmsam.github.io/forgot/reference/simple_reactable_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get simple reactable table — simple_reactable_table","text":"","code":"simple_reactable_table(iris)  {\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"Sepal.Length\":[5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9,5.4,4.8,4.8,4.3,5.8,5.7,5.4,5.1,5.7,5.1,5.4,5.1,4.6,5.1,4.8,5,5,5.2,5.2,4.7,4.8,5.4,5.2,5.5,4.9,5,5.5,4.9,4.4,5.1,5,4.5,4.4,5,5.1,4.8,5.1,4.6,5.3,5,7,6.4,6.9,5.5,6.5,5.7,6.3,4.9,6.6,5.2,5,5.9,6,6.1,5.6,6.7,5.6,5.8,6.2,5.6,5.9,6.1,6.3,6.1,6.4,6.6,6.8,6.7,6,5.7,5.5,5.5,5.8,6,5.4,6,6.7,6.3,5.6,5.5,5.5,6.1,5.8,5,5.6,5.7,5.7,6.2,5.1,5.7,6.3,5.8,7.1,6.3,6.5,7.6,4.9,7.3,6.7,7.2,6.5,6.4,6.8,5.7,5.8,6.4,6.5,7.7,7.7,6,6.9,5.6,7.7,6.3,6.7,7.2,6.2,6.1,6.4,7.2,7.4,7.9,6.4,6.3,6.1,7.7,6.3,6.4,6,6.9,6.7,6.9,5.8,6.8,6.7,6.7,6.3,6.5,6.2,5.9],\"Sepal.Width\":[3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1,3.7,3.4,3,3,4,4.4,3.9,3.5,3.8,3.8,3.4,3.7,3.6,3.3,3.4,3,3.4,3.5,3.4,3.2,3.1,3.4,4.1,4.2,3.1,3.2,3.5,3.6,3,3.4,3.5,2.3,3.2,3.5,3.8,3,3.8,3.2,3.7,3.3,3.2,3.2,3.1,2.3,2.8,2.8,3.3,2.4,2.9,2.7,2,3,2.2,2.9,2.9,3.1,3,2.7,2.2,2.5,3.2,2.8,2.5,2.8,2.9,3,2.8,3,2.9,2.6,2.4,2.4,2.7,2.7,3,3.4,3.1,2.3,3,2.5,2.6,3,2.6,2.3,2.7,3,2.9,2.9,2.5,2.8,3.3,2.7,3,2.9,3,3,2.5,2.9,2.5,3.6,3.2,2.7,3,2.5,2.8,3.2,3,3.8,2.6,2.2,3.2,2.8,2.8,2.7,3.3,3.2,2.8,3,2.8,3,2.8,3.8,2.8,2.8,2.6,3,3.4,3.1,3,3.1,3.1,3.1,2.7,3.2,3.3,3,2.5,3,3.4,3],\"Petal.Length\":[1.4,1.4,1.3,1.5,1.4,1.7,1.4,1.5,1.4,1.5,1.5,1.6,1.4,1.1,1.2,1.5,1.3,1.4,1.7,1.5,1.7,1.5,1,1.7,1.9,1.6,1.6,1.5,1.4,1.6,1.6,1.5,1.5,1.4,1.5,1.2,1.3,1.4,1.3,1.5,1.3,1.3,1.3,1.6,1.9,1.4,1.6,1.4,1.5,1.4,4.7,4.5,4.9,4,4.6,4.5,4.7,3.3,4.6,3.9,3.5,4.2,4,4.7,3.6,4.4,4.5,4.1,4.5,3.9,4.8,4,4.9,4.7,4.3,4.4,4.8,5,4.5,3.5,3.8,3.7,3.9,5.1,4.5,4.5,4.7,4.4,4.1,4,4.4,4.6,4,3.3,4.2,4.2,4.2,4.3,3,4.1,6,5.1,5.9,5.6,5.8,6.6,4.5,6.3,5.8,6.1,5.1,5.3,5.5,5,5.1,5.3,5.5,6.7,6.9,5,5.7,4.9,6.7,4.9,5.7,6,4.8,4.9,5.6,5.8,6.1,6.4,5.6,5.1,5.6,6.1,5.6,5.5,4.8,5.4,5.6,5.1,5.1,5.9,5.7,5.2,5,5.2,5.4,5.1],\"Petal.Width\":[0.2,0.2,0.2,0.2,0.2,0.4,0.3,0.2,0.2,0.1,0.2,0.2,0.1,0.1,0.2,0.4,0.4,0.3,0.3,0.3,0.2,0.4,0.2,0.5,0.2,0.2,0.4,0.2,0.2,0.2,0.2,0.4,0.1,0.2,0.2,0.2,0.2,0.1,0.2,0.2,0.3,0.3,0.2,0.6,0.4,0.3,0.2,0.2,0.2,0.2,1.4,1.5,1.5,1.3,1.5,1.3,1.6,1,1.3,1.4,1,1.5,1,1.4,1.3,1.4,1.5,1,1.5,1.1,1.8,1.3,1.5,1.2,1.3,1.4,1.4,1.7,1.5,1,1.1,1,1.2,1.6,1.5,1.6,1.5,1.3,1.3,1.3,1.2,1.4,1.2,1,1.3,1.2,1.3,1.3,1.1,1.3,2.5,1.9,2.1,1.8,2.2,2.1,1.7,1.8,1.8,2.5,2,1.9,2.1,2,2.4,2.3,1.8,2.2,2.3,1.5,2.3,2,2,1.8,2.1,1.8,1.8,1.8,2.1,1.6,1.9,2,2.2,1.5,1.4,2.3,2.4,1.8,1.8,2.1,2.4,2.3,1.9,2.3,2.5,2.3,1.9,2,2.3,1.8],\"Species\":[\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"setosa\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"versicolor\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\",\"virginica\"]},\"columns\":[{\"id\":\"Sepal.Length\",\"name\":\"Sepal.Length\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Sepal.Width\",\"name\":\"Sepal.Width\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Petal.Length\",\"name\":\"Petal.Length\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Petal.Width\",\"name\":\"Petal.Width\",\"type\":\"numeric\",\"minWidth\":120},{\"id\":\"Species\",\"name\":\"Species\",\"type\":\"factor\",\"minWidth\":120}],\"resizable\":true,\"filterable\":true,\"defaultPageSize\":4,\"showPageSizeOptions\":true,\"pageSizeOptions\":[4,8,12],\"highlight\":true,\"bordered\":true,\"nowrap\":true,\"dataKey\":\"3f7bb21cea252c825589d9fb005a0c99\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://parmsam.github.io/forgot/news/index.html","id":"forgot-010","dir":"Changelog","previous_headings":"","what":"forgot 0.1.0","title":"forgot 0.1.0","text":"Added NEWS.md file track changes package. Added forgot() forgot2() return tibble roxygen2 field data Added forgot_fx() generally search specific function interest Added forgot_exmpls(), forgot_params(), forgot_usg() specifically invisibly return string factor cat vector console","code":""}]
