<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Print examples for an R function of interest in console"><title>Print examples for an R function of interest in console — forgot_exmpls • forgot</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Print examples for an R function of interest in console — forgot_exmpls"><meta property="og:description" content="Print examples for an R function of interest in console"><meta property="og:image" content="https://parmsam.github.io/forgot/logo.png"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">forgot</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"></ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Print examples for an R function of interest in console</h1>
      
      <div class="d-none name"><code>forgot_exmpls.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Print examples for an R function of interest in console</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">forgot_exmpls</span><span class="op">(</span><span class="va">pkg</span>, <span class="va">function_name</span>, write <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>pkg</dt>
<dd><p>string with installed R package name</p></dd>


<dt>function_name</dt>
<dd><p>function name in R package</p></dd>


<dt>write</dt>
<dd><p>logical write to RStudio rmd file, FALSE by default</p></dd>

</dl></div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu">forgot_exmpls</span><span class="op">(</span><span class="st">"dplyr"</span>, <span class="st">"count"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For better printing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # across() -----------------------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Different ways to select the same set of columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # See &lt;https://tidyselect.r-lib.org/articles/syntax.html&gt; for details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(c(Sepal.Length, Sepal.Width), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(c(1, 2), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(1:Sepal.Width, round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(where(is.double) &amp; !c(Petal.Length, Petal.Width), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Using an external vector of names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cols &lt;- c("Sepal.Length", "Petal.Width")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(all_of(cols), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the external vector is named, the output columns will be named according</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to those names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> names(cols) &lt;- tolower(cols)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(all_of(cols), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A purrr-style formula</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A named list of functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use the .names argument to control the output names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), mean, .names = "mean_{.col}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd), .names = "{.col}.{.fn}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a named external vector is used for column selection, .names will use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # those names when constructing the output names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(all_of(cols), mean, .names = "mean_{.col}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When the list is not named, .fn is replaced by the function's position</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean, sd), .names = "{.col}.fn{.fn}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When the functions in .fns return a data frame, you typically get a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # "packed" data frame back</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(quantile = probs, value = quantile(x, probs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use .unpack to automatically expand these packed data frames into their</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # individual columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df, .unpack = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # .unpack can utilize a glue specification if you don't like the defaults</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df, .unpack = "{outer}.{inner}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is also useful inside mutate(), for example, with a multi-lag helper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> multilag &lt;- function(x, lags = 1:3) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   names(lags) &lt;- as.character(lags)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   purrr::map_dfr(lags, lag, x = x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(starts_with("Sepal"), multilag, .unpack = TRUE)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(Species, starts_with("Sepal"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # if_any() and if_all() ----------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(if_any(ends_with("Width"), ~ . &gt; 4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(if_all(ends_with("Width"), ~ . &gt; 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scramble &lt;- function(x) x[sample(nrow(x)), sample(ncol(x))]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `all_equal()` ignored row and column ordering by default,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # but we now feel that that makes it too easy to make mistakes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars2 &lt;- scramble(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all_equal(mtcars, mtcars2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Instead, be explicit about the row and column ordering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all.equal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mtcars,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mtcars2[rownames(mtcars), names(mtcars)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(mtcars, cyl, disp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(mtcars, desc(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # grouped arrange ignores groups</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% arrange(desc(wt))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unless you specifically ask:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% arrange(desc(wt), .by_group = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use embracing when wrapping in a function;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see ?rlang::args_data_masking for more details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tidy_eval_arrange &lt;- function(.data, var) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .data %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     arrange({{ var }})</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tidy_eval_arrange(mtcars, mpg)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `across()` or `pick()` to select columns with tidy-select</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% arrange(pick(starts_with("Sepal")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% arrange(across(starts_with("Sepal"), desc))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- as_tibble(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange_all(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange_all(df, desc)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, across(everything(), desc))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_instruments</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_instruments2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> between(1:12, 7, 9)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- rnorm(1e2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x[between(x, -1, 1)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # On a tibble using `filter()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, between(height, 100, 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(y = 3:1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_cols(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Row sizes must be compatible when column-binding</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:2, y = letters[1:2])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = 4:5, z = 1:2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can supply individual data frames as arguments:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or a list of data frames:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(df1, df2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When you supply a column name with the `.id` argument, a new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # column is created to link each row to its original data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(df1, df2), .id = "id")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(a = df1, b = df2), .id = "id")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sum = sum(c_across(w:z)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sd = sd(c_across(w:z))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c("a", "b", "a", "d", "b", NA, "c", "e")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` acts like a vectorized `switch()`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unmatched values "fall through" as a missing value.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "a" ~ 1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "b" ~ 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c" ~ 3,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "d" ~ 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Missing values can be matched exactly, and `.default` can be used to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # control the value used for unmatched values of `.x`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "a" ~ 1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "b" ~ 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c" ~ 3,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "d" ~ 4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   NA ~ 0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = 100</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Input values can be grouped into the same expression to map them to the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # same output value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c("a", "b") ~ "low",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c("c", "d", "e") ~ "high"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` isn't limited to character input:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(1, 2, 1, 3, 1, NA, 2, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(1, 3) ~ "odd",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(2, 4) ~ "even",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "missing"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Setting `.default` to the original vector is a useful way to replace</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # selected values, leaving everything else as is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(y, NA ~ 0, .default = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     # Replace missings, but leave everything else alone</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     # Replace some, but not all, of the species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     species = case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       species,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       "Human" ~ "Humanoid",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       "Droid" ~ "Robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       c("Wookiee", "Ewok") ~ "Hairy",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       .default = species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .keep = "used"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:70</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Like an if statement, the arguments are evaluated in order, so you must</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # proceed from the most specific to the most general. This won't work:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %%  5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %%  7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If none of the cases match and no `.default` is supplied, NA is used:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that `NA` values on the LHS are treated like `FALSE` and will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # assigned the `.default` value. You must handle them explicitly if you</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # want to use a different value. The exact way to handle missing values is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # dependent on the set of LHS conditions you use.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x[2:4] &lt;- NA_real_</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   is.na(x) ~ "nope",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` evaluates all RHS expressions, and then constructs its</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # result by extracting the selected (via the LHS expressions) parts.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In particular `NaN`s are produced in this case:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- seq(-2, 2, by = .5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y &gt;= 0 ~ sqrt(y),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` is particularly useful inside `mutate()` when you want to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # create a new variable that relies on a complex combination of existing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name:mass, gender, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     type = case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` is not a tidy eval function. If you'd like to reuse</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the same patterns, extract the `case_when()` call in a normal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type &lt;- function(height, mass, species) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type(150, 250, "Droid")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type(150, 150, "Droid")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Such functions can be used inside `mutate()` as well:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(type = case_character_type(height, mass, species)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` ignores `NULL` inputs. This is useful when you'd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # like to use a pattern only under certain conditions. Here we'll</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # take advantage of the fact that `if` returns `NULL` when there is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # no `else` clause:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type &lt;- function(height, mass, species, robots = TRUE) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (robots) species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(type = case_character_type(height, mass, species, robots = FALSE)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrap_dbplyr_obj("build_sql")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrap_dbplyr_obj("base_agg")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use a single value to replace all missing values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- sample(c(1:5, NA, NA, NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(x, 0L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The equivalent to a missing value in a list is `NULL`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(list(1, 2, NULL), list(NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or generate a complete vector from partially missing pieces</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(1, 2, NA, NA, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(NA, NA, 3, 4, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(y, z)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Supply lists by splicing them into dots:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vecs &lt;- list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(1, 2, NA, NA, 5),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(NA, NA, 3, 4, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(!!!vecs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> f1 &lt;- factor("a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> f2 &lt;- factor("b")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> combine(f1, f2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vctrs::vec_c(f1, f1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> combine(list(f1, f2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vctrs::vec_c(!!!list(f1, f2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars2 &lt;- dbplyr::src_memdb() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   copy_to(mtcars, name = "mtcars2-cc", overwrite = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> remote &lt;- mtcars2 %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(cyl == 8) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(mpg:drat)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute query and save in remote table</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> compute(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute query bring back to this session</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> collect(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Creates a fresh query based on the generated SQL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> collapse(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(x, y) %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(id = consecutive_id(x, y), x, y) %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = sample(rep(letters[1:3], 1:3)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = runif(6),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = runif(6)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf &lt;- df %&gt;% group_by(g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% mutate(id = cur_group_id())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% reframe(row = cur_group_rows())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% summarise(data = list(cur_group()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontrun{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris2 &lt;- dbplyr::src_memdb() %&gt;% copy_to(iris, overwrite = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # count() is a convenient way to get a sense of the distribution of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # values in a dataset</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(species, sort = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(sex, gender, sort = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(birth_decade = round(birth_year, -1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use the `wt` argument to perform a weighted count. This is useful</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # when the data has already been aggregated once</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tribble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~name,    ~gender,   ~runs,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Max",    "male",       10,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Sandra", "female",      1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Susan",  "female",      4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # counts rows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(gender)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # counts runs:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(gender, wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When factors are involved, `.drop = FALSE` can be used to retain factor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # levels that don't appear in the data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = 1:5,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   type = factor(c("a", "c", "a", NA, "a"), levels = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% count(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% count(type, .drop = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or, using `group_by()`:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% group_by(type, .drop = FALSE) %&gt;% count()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tally() is a lower-level function that assumes you've done the grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% tally()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% group_by(species) %&gt;% tally()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # both count() and tally() have add_ variants that work like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mutate() instead of summarise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% add_count(gender, wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% add_tally(wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Cross joins match each row in `x` to every row in `y`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Data within the columns is not used in the matching process.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cross_join(band_instruments, band_members)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Control the suffix added to variables duplicated in</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `x` and `y` with `suffix`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cross_join(band_instruments, band_members, suffix = c("", "_y"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cummean()` returns a numeric/integer vector of the same length</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # as the input vector.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, 3, 5, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cummean(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumsum(x) / seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cumall()` and `cumany()` return logicals</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumall(x &lt; 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumany(x == 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cumall()` vs. `cumany()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   date = as.Date("2020-01-01") + 0:6,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   balance = c(100, 50, 25, -25, -50, 30, 120)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all rows after first overdraft</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% filter(cumany(balance &lt; 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all rows until first overdraft</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% filter(cumall(!(balance &lt; 0)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(1:10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(factor(letters))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first_day &lt;- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(first_day)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% arrange(desc(mass))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dim_desc(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = sample(10, 100, rep = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = sample(10, 100, rep = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(distinct(df))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(distinct(df, x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can choose to keep all other variables as well</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, x, .keep_all = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, y, .keep_all = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also use distinct on computed variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, diff = abs(x - y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `pick()` to select columns with tidy-select</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(starwars, pick(contains("color")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Grouping -------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = c(1, 1, 2, 2, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(1, 1, 2, 1, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(3, 2, 1, 3, 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- df %&gt;% group_by(g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # With grouped data frames, distinctness is computed within each group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% distinct(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When `...` are omitted, `distinct()` still computes distinctness using</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all variables in the data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% distinct()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_all(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_at(df, vars(x,y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_if(df, is.numeric)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(where(is.numeric)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can supply a function that will be applied before extracting the distinct values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The variables of the sorted tibble keep their original values.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_all(df, round)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, across(everything(), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # do() with unnamed arguments becomes reframe() or summarise()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # . becomes pick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% do(head(., 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% reframe(head(pick(everything()), 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% slice_head(n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Can refer to variables directly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% do(mean = mean(.$vs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% summarise(mean = mean(vs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # do() with named arguments becomes nest_by() + mutate() &amp; list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- by_cyl %&gt;% do(mod = lm(mpg ~ disp, data = .))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   nest_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mod = list(lm(mpg ~ disp, data = data)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(rsq = summary(mod)$r.squared)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use broom to turn models into data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% do(data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   var = names(coef(.$mod)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   coef(summary(.$mod)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(broom::tidy(mod))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (dplyr:::has_minimum_stringi()) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c("a", "b", "C", "B", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Default locale is C, which groups the English alphabet by case, placing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # uppercase letters before lowercase letters.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The American English locale groups the alphabet by letter.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Explicitly override `.locale` with `"en"` for this ordering.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "en")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This Danish letter is expected to sort after `z`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c("o", "p", "\u00F8", "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The American English locale sorts it right after `o`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "en")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Using `"da"` for Danish ordering gives the expected result</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "da")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you need the legacy behavior of `arrange()`, which respected the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # system locale, then you can set the global option `dplyr.legacy_locale`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # but expect this to be removed in the future. We recommend that you use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the `.locale` argument instead.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rlang::with_options(dplyr.legacy_locale = TRUE, {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   arrange(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \donttest{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lahman_s &lt;- dbplyr::lahman_sqlite()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting &lt;- tbl(lahman_s, "Batting")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% show_query()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The batting database has indices on all ID variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # SQLite automatically picks the most restrictive index</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% filter(lgID == "NL" &amp; yearID == 2000L) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # OR's will use multiple indexes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% filter(lgID == "NL" | yearID == 2000) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Joins will use indexes in both tables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> teams &lt;- tbl(lahman_s, "Teams")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% left_join(teams, c("yearID", "teamID")) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # "Filtering" joins keep cases from the LHS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% semi_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% anti_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To suppress the message about joining variables, supply `by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% semi_join(band_instruments, by = join_by(name))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is good practice in production code</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filtering by one criterion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, species == "Human")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, mass &gt; 1000)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filtering by multiple criteria within a single logical expression</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none" &amp; eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none" | eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When multiple expressions are used, they are combined using &amp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none", eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The filtering operation may yield different results on grouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tibbles because the expressions are computed within groups.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The following filters rows where `mass` is greater than the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # global average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Whereas this keeps rows with `mass` greater than the gender</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% group_by(gender) %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To refer to column names that are stored as strings, use the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vars &lt;- c("mass", "height")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cond &lt;- c(80, 150)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .data[[vars[[1]]]] &gt; cond[[1]],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .data[[vars[[2]]]] &gt; cond[[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # While filter() accepts expressions with specific variables, the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # scoped filter verbs take an expression with the pronoun `.` and</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # replicate it over all variables. This expression should be quoted</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # with all_vars() or any_vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all_vars(is.na(.))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> any_vars(is.na(.))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can take the intersection of the replicated expressions:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_all(mtcars, all_vars(. &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_all(everything(), ~ .x &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or the union:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_all(mtcars, any_vars(. &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_any(everything(), ~ . &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can vary the selection of columns on which to apply the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # predicate. filter_at() takes a vars() specification:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_at(mtcars, vars(starts_with("d")), any_vars((. %% 2) == 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_any(starts_with("d"), ~ (.x %% 2) == 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # And filter_if() selects variables with a predicate function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> is_int &lt;- function(x) all(floor(x) == x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_all(where(is_int), ~ .x != 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> funs("mean", mean(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list(mean = mean, mean = ~ mean(.x, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> funs(m1 = mean, m2 = "mean", m3 = mean(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list(m1 = mean, m2 = "mean", m3 = ~ mean(.x, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> glimpse(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that original x is (invisibly) returned, allowing `glimpse()` to be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # used within a pipeline.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   glimpse() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> glimpse(starwars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # grouping doesn't change how the data looks (apart from listing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # how it's grouped):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It changes how it acts with the other dplyr verbs:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% summarise(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   disp = mean(disp),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   hp = mean(hp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% filter(disp == max(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Each call to summarise() removes a layer of grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs_am &lt;- mtcars %&gt;% group_by(vs, am)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs &lt;- by_vs_am %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs %&gt;% summarise(n = sum(n))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To removing grouping, use ungroup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ungroup() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(n = sum(n))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, group_by() overrides existing grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs, am) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use add = TRUE to instead append</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs, am, .add = TRUE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can group by expressions: this is a short-hand</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # for a mutate() followed by a group_by()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vsam = vs + am)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The implicit mutate() step is always performed on the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # ungrouped data. Here we get 3 groups:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(hp_cut = cut(hp, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want it to be performed by groups,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you have to use an explicit mutate() call.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Here we get 3 groups per value of vs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(hp_cut = cut(hp, 3)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(hp_cut)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # when factors are involved and .drop = FALSE, groups can be empty</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = 1:10,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = factor(rep(c("a", "c"), each  = 5), levels = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(y, .drop = FALSE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_rows()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group a data frame by all variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_all(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% group_by(pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group by variables selected with a predicate:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_if(iris, is.factor)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% group_by(pick(where(is.factor)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group by variables selected by name:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_at(mtcars, vars(vs, am))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% group_by(pick(vs, am))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Like group_by(), the scoped variants have optional mutate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # semantics. This provide a shortcut for group_by() + mutate():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d &lt;- tibble(x=c(1,1,2,2), y=c(1,2,1,2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_all(d, as.factor)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d %&gt;% group_by(across(everything(), as.factor))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_if(iris, is.factor, as.character)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% group_by(across(where(is.factor), as.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_drop_default(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by_drop_default()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species, .drop = FALSE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by_drop_default()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf &lt;- iris %&gt;% group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% select(group_cols())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Remove the grouping variables from mutate selections:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% mutate_at(vars(-group_cols()), `/`, 100)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt; No longer necessary with across()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% mutate(across(everything(), ~ . / 100))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c(1,1,2,2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_vars(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_rows(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_data(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_indices(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf &lt;- group_by(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_vars(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_rows(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_data(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_indices(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # return a list</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # return a tibble grouped by `cyl` with 2 rows per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the grouping data is recalculated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a list of tibbles</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a restructured grouped tibble</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a list of vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to use group_modify() the lambda must return a data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      tibble::enframe(name = "prob", value = "quantile")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .x %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       purrr::map_dfc(fivenum) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       mutate(nms = c("min", "Q1", "median", "Q3", "max"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # group_walk() is for side effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dir.create(temp &lt;- tempfile())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list.files(temp, pattern = "csv$")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> unlink(temp, recursive = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # group_modify() and ungrouped data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #----- use case 1: a grouped data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # this can be useful if the grouped data has been altered before nesting</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(Sepal.Length &gt; mean(Sepal.Length)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #----- use case 2: using group_nest() on a ungrouped data frame with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #                  a grouping specification that uses the data mask</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest(species, homeworld)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ir &lt;- iris %&gt;% group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_split(ir)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_keys(ir)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(Species == "setosa", .preserve = TRUE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_trim()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Identifiers are escaped with "</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ident("x")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(-5:5, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x &lt; 0, NA, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Explicitly handle `NA` values in the `condition` with `missing`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x &lt; 0, "negative", "positive", missing = "missing")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unlike `ifelse()`, `if_else()` preserves types</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- factor(sample(letters[1:5], 10, replace = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ifelse(x %in% c("a", "b", "c"), x, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x %in% c("a", "b", "c"), x, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `if_else()` is often useful for creating new columns inside of `mutate()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(category = if_else(height &lt; 100, "short", "tall"), .keep = "used")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = c(1L, 1L, 1L, 2L, 2L),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> promos &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = c(1L, 1L, 2L),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> promos</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Match `id` to `id`, and `sale_date` to `promo_date`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, sale_date == promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For each `sale_date` within a particular `id`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # find all `promo_date`s that occurred before that particular sale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, sale_date &gt;= promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For each `sale_date` within a particular `id`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # find only the closest `promo_date` that occurred before that sale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt;= promo_date))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to disallow exact matching in rolling joins, use `&gt;` rather</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # than `&gt;=`. Note that the promo on `2019-01-05` is no longer considered the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # closest match for the sale on the same date.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt; promo_date))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Same as before, but also require that the promo had to occur at most 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # day before the sale was made. We'll use a full join to see that id 2's</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales &lt;- mutate(sales, sale_date_lower = sale_date - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt;= promo_date), sale_date_lower &lt;= promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # ---------------------------------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> segments &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   segment_id = 1:4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   chromosome = c("chr1", "chr2", "chr2", "chr1"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   start = c(140, 210, 380, 230),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   end = c(150, 240, 415, 280)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> segments</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> reference &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reference_id = 1:4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   chromosome = c("chr1", "chr1", "chr2", "chr2"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   start = c(100, 200, 300, 415),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   end = c(150, 250, 399, 450)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> reference</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment `start` falls between the reference</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `[start, end]` range.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, between(start, start, end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you wanted the reference columns first, supply `reference` as `x`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and `segments` as `y`, then explicitly refer to their columns using `x$`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and `y$`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, between(y$start, x$start, x$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(reference, segments, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment falls completely within a reference.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Sometimes using `x$` and `y$` makes your intentions clearer, even if they</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # match the default behavior.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, within(x$start, x$end, y$start, y$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> inner_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment overlaps a reference in any way.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It is common to have right-open ranges with bounds like `[)`, which would</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mean an end value of `415` would no longer overlap a start value of `415`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Setting `bounds` allows you to compute overlaps with those kinds of ranges.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = "[)"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tibble(behind = lag(x), x, ahead = lead(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to look more rows behind or ahead, use `n`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to define a value to pad with, use `default`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, default = 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, default = 6)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the data are not already ordered, use `order_by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scrambled &lt;- slice_sample(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(year = 2000:2005, value = (0:5) ^ 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   prop = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrong &lt;- mutate(scrambled, previous_year_value = lag(value))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(wrong, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> right &lt;- mutate(scrambled, previous_year_value = lag(value, order_by = year))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(right, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% inner_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% left_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% right_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% full_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To suppress the message about joining variables, supply `by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% inner_join(band_instruments, by = join_by(name))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is good practice in production code</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use an equality expression if the join variables have different names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% full_join(band_instruments2, by = join_by(name == artist))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, the join keys from `x` and `y` are coalesced in the output; use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `keep = TRUE` to keep the join keys from both `x` and `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   full_join(band_instruments2, by = join_by(name == artist), keep = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a row in `x` matches multiple rows in `y`, all the rows in `y` will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returned once for each matching row in `x`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(1, 1, 2), y = c("first", "second", "third"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 %&gt;% left_join(df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a row in `y` also matches multiple rows in `x`, this is known as a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # many-to-many relationship, which is typically a result of an improperly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # specified join or some kind of messy data. In this case, a warning is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # thrown by default:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 &lt;- tibble(x = c(1, 1, 1, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 %&gt;% left_join(df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In the rare case where a many-to-many relationship is expected, set</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `relationship = "many-to-many"` to silence this warning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 %&gt;% left_join(df2, relationship = "many-to-many")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `join_by()` with a condition other than `==` to perform an inequality</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # join. Here we match on every instance where `df1$x &gt; df2$x`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 %&gt;% left_join(df2, join_by(x &gt; x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, NAs match other NAs so that there are two</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # rows in the output of this join:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- data.frame(x = c(1, NA), y = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- data.frame(x = c(1, NA), z = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can optionally request that NAs don't match, giving a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a result that more closely resembles SQL joins</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(df1, df2, na_matches = "never")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Newly created variables are available immediately</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass2 = mass * 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass2_squared = mass2 * mass2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # As well as adding new variables, you can use mutate() to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # remove variables and modify existing variables.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, height, mass, homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass = NULL,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height = height * 0.0328084 # convert to feet</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use across() with mutate() to apply a transformation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to multiple columns in a tibble.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, homeworld, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(!name, as.factor))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see more in ?across</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Window functions are useful for grouped mutates:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(rank = min_rank(desc(mass)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see `vignette("window-functions")` for more details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, new columns are placed on the far right.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1, y = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .before = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .after = x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, mutate() keeps all columns from the input data.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1, y = 2, a = "a", b = "b")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "all") # the default</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "used")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "unused")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "none")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Grouping ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The mutate operation may yield different results on grouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tibbles because the expressions are computed within groups.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The following normalises `mass` by the global average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Whereas this normalises `mass` by the averages within species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # levels:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Indirection ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Refer to column names stored as strings with the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vars &lt;- c("mass", "height")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # All variants can be passed functions and additional arguments,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # purrr-style. The _at() variants directly support strings. Here</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # we'll scale the variables `height` and `mass`:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scale2 &lt;- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), scale2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(c("height", "mass"), scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can pass additional arguments to the function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), scale2, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), ~scale2(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(c("height", "mass"), ~ scale2(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also supply selection helpers to _at() functions but you have</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to quote them with vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_at(vars(matches("Sepal")), log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(matches("Sepal"), log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _if() variants apply a predicate function (a function that</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returns TRUE or FALSE) to determine the relevant subset of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # columns. Here we divide all the numeric columns by 100:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_if(is.numeric, scale2, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mutate_if() is particularly useful for transforming variables from</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # one type to another</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.factor, as.character)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.double, as.integer)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(where(is.factor), as.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(where(is.double), as.integer))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Multiple transformations ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to apply multiple transformations, pass a list of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # functions. When there are multiple functions, they create new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables instead of modifying the variables in place:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale2, log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(~scale2(.), ~log(.)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale = scale2, log = log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   as_tibble() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(where(is.numeric), list(scale = scale2, log = log)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When there's only one function in the list, it modifies existing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables in place. Give it a name to instead create new variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale = scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, 1, 2, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(3, 3, NA, 3, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(y, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Pairs (1, 3), (2, 3), and (2, NA) are distinct</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # (2, NA) is dropped, leaving 2 distinct combinations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x, y, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Also works with data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(data.frame(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(1:5, 5:1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, -1, 0, 10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 100 / x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 100 / na_if(x, 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c("abc", "def", "", "ghi")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(y, "")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` allows you to replace `NaN` with `NA`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # even though `NaN == NaN` returns `NA`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(1, NaN, NA, 2, NaN)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(z, NaN)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` is particularly useful inside `mutate()`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and is meant for use with vectors rather than entire data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, eye_color) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(eye_color = na_if(eye_color, "unknown"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` can also be used with `mutate()` and `across()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to alter multiple columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    mutate(across(where(is.character), ~na_if(., "unknown")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sqrt(2) ^ 2 == 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> near(sqrt(2) ^ 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # After nesting, you get one row per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% nest_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% nest_by(species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The output is grouped by row, which makes modelling particularly easy</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   nest_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(model = list(lm(mpg ~ wt, data = data)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(rsq = summary(model)$r.squared)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is particularly elegant with the broom functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(broom::glance(model))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(broom::tidy(model))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that you can also `reframe()` to unnest the data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(2, 3, 3), y = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out &lt;- nest_join(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out$df2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # 5 bootstrap samples</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl &lt;- new_grouped_df(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(x = rnorm(10)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   groups = tibble(".rows" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mean of each bootstrap sample</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> summarise(tbl, x = mean(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:10</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- 10:1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, -2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `first()` and `last()` are often useful in `summarise()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = x, y = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     across(x:y, first, .names = "{col}_first"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     y_last = last(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Selecting a position that is out of bounds returns a default value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 11)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This out of bounds behavior also applies to empty vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(integer())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can customize the default value with `default`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 11, default = -1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(integer(), default = 0L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `order_by` provides optional ordering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(x, order_by = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_rm` removes missing values before extracting the value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(NA, NA, 1, 3, NA, 5, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(z)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(z, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(z, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(z, 3, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For data frames, these select entire rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(a = 1:5, b = 6:10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(df, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(x, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(x, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the bucket sizes are uneven, the larger buckets come first</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(1:8, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Ties are ignored</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(rep(1, 8), 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> order_by(10:1, cumsum(1:10))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 10:1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- 1:10</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> order_by(x, cumsum(y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(year = 2000:2005, value = (0:5) ^ 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scrambled &lt;- df[sample(nrow(df)), ]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrong &lt;- mutate(scrambled, running = cumsum(value))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(wrong, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> right &lt;- mutate(scrambled, running = order_by(year, cumsum(value)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(right, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cume_dist(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> percent_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can understand what's going on by computing it by hand</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sapply(x, function(xi) sum(x &lt;= xi) / length(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sapply(x, function(xi) sum(x &lt; xi)  / (length(x) - 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The real computations are a little more complex in order to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # correctly deal with missing values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(3, 2, 2, 2, 1),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(0, 2, 1, 1, 4),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z1 = c("a", "a", "a", "b", "a"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z2 = c("c", "d", "d", "a", "c")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `pick()` provides a way to select a subset of your columns using</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tidyselect. It returns a data frame.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(cols = pick(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is useful for functions that take data frames as inputs.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For example, you can compute a joint rank between `x` and `y`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(rank = dense_rank(pick(x, y)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `pick()` is also useful as a bridge between data-masking functions (like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `mutate()` or `group_by()`) and functions with tidy-select behavior (like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `select()`). For example, you can use `pick()` to create a wrapper around</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `group_by()` that takes a tidy-selection of columns to group on. For more</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # bridge patterns, see</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> my_group_by &lt;- function(data, cols) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(data, pick({{ cols }}))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% my_group_by(c(x, starts_with("z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or you can use it to dynamically select columns to `count()` by</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(pick(starts_with("z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:3) p$pause(0.1)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()$print()$</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  pause(1)$stop()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If min_time is set, progress bar not shown until that many</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # seconds have elapsed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3, min_time = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:3) p$pause(0.1)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontrun{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(10, min_time = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:10) p$pause(0.5)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(-1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Also works for remote sources</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = "pull-ex")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(z = x * y) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Pull a named vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% pull(height, name)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> char_vec &lt;- sample(c("a", "b", "c"), 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode()` is superseded by `case_match()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(char_vec, a = "Apple", b = "Banana")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = char_vec)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # With `case_match()`, you don't need typed missings like `NA_character_`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Throws an error as `NA` is logical, not character.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(recode(char_vec, a = "Apple", b = "Banana", .default = NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` is easier to use with numeric vectors, because you don't</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # need to turn the numeric values into names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> num_vec &lt;- c(1:4, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, `2` = 20L, `4` = 40L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` doesn't have the ability to match by position like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode()` does with numeric vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, "a", "b", "c", "d")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(c(1,5,3), "a", "b", "c", "d", .default = "nothing")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For `case_match()`, incompatible types are an error rather than a warning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, `2` = "b", `4` = "d")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(case_match(num_vec, 2 ~ "b", 4 ~ "d", .default = num_vec))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The factor method of `recode()` can generally be replaced with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `forcats::fct_recode()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> factor_vec &lt;- factor(c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(factor_vec, a = "Apple")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode_factor()` does not currently have a direct replacement, but we</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # plan to add one to forcats. In the meantime, you can use the `.ptype`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # argument to `case_match()`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode_factor(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   num_vec,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `1` = "z",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `2` = "y",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `3` = "x",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "D",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .missing = "M"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   num_vec,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   1 ~ "z",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   2 ~ "y",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   3 ~ "x",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   NA ~ "M",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "D",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .ptype = factor(levels = c("z", "y", "x", "D", "M"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> table &lt;- c("a", "b", "d", "f")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = c(1, 1, 1, 2, 2, 2, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c("e", "a", "b", "c", "f", "d", "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `reframe()` allows you to apply functions that return</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # an arbitrary number of rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Functions are applied per group, and each group can return a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # different number of rows.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table), .by = g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The output is always ungrouped, even when using `group_by()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(g) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can add multiple columns at once using a single expression by returning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a data frame.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     val = quantile(x, probs, na.rm = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     quant = probs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(10, 15, 18, 12)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(quantile_df(height))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(quantile_df(height), .by = homeworld)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     across(c(height, mass), quantile_df, .unpack = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .by = homeworld</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(f)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(a, .after = c)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(f, .before = b)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(a, .after = last_col())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # relocated columns can change name</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(ff = f)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Can also select variables based on their type</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(where(is.numeric), .after = last_col())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or with any other select helper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(any_of(c("a", "e", "i", "o", "u")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When .before or .after refers to multiple variables they will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # moved to be immediately before/after the selected variables.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(a = 1, b = "a", c = 1, d = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% relocate(where(is.numeric), .after = where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% relocate(where(is.numeric), .before = where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris) # so it prints a little nicer</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, petal_length = Petal.Length)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rename using a named vector and `all_of()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lookup &lt;- c(pl = "Petal.Length", sl = "Sepal.Length")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, all_of(lookup))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If your named vector might contain names that don't exist in the data,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use `any_of()` instead</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lookup &lt;- c(lookup, new = "unknown")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rename(iris, all_of(lookup)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, any_of(lookup))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, toupper, starts_with("Petal"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, ~ tolower(gsub(".", "_", .x, fixed = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (getRversion() &gt; "4.0.1") (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If your renaming function uses `paste0()`, make sure to set</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recycle0 = TRUE` to ensure that empty selections are recycled correctly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rename_with(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   iris,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~ paste0("prefix_", .x),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   starts_with("nonexistent")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   iris,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~ paste0("prefix_", .x, recycle0 = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   starts_with("nonexistent")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> row_number(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> min_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dense_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Ranking functions can be used in `filter()` to select top/bottom rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(3, 2, 1, 1, 2, 2, 1, 1, 1),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(1, 3, 2, 3, 2, 2, 4, 1, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = 1:9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Always gives exactly 1 row per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(row_number(x) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # May give more than 1 row if ties</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(min_rank(x) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rank by multiple columns (to break ties) by selecting them with `pick()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(min_rank(pick(x, y)) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # See slice_min() and slice_max() for another way to tackle the same problem</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can use row_number() without an argument to refer to the "current"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # row number.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(row_number() == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It's easiest to see what this does with mutate():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% mutate(grp_id = row_number())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data &lt;- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Insert</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_insert(data, tibble(a = 4, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, if a key in `y` matches a key in `x`, then it can't be inserted</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and will throw an error. Alternatively, you can ignore rows in `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # containing keys that conflict with keys in `x` with `conflict = "ignore"`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # or you can use `rows_append()` to ignore keys entirely.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rows_insert(data, tibble(a = 3, b = "z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_insert(data, tibble(a = 3, b = "z"), conflict = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_append(data, tibble(a = 3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Update</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, tibble(a = 2:3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, tibble(b = "z", a = 2:3), by = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Variants: patch and upsert</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_patch(data, tibble(a = 2:3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_upsert(data, tibble(a = 2:4, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Delete and truncate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, tibble(a = 2:3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, tibble(a = 2:3, b = "b"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, for update, patch, and delete it is an error if a key in `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # with `unmatched = "ignore"`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- tibble(a = 3:4, b = "z")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rows_update(data, y, by = "a"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_patch(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = runif(6), y = runif(6), z = runif(6))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute the mean of x, y, z in each row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use c_across() to more easily select many variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = mean(c_across(x:z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute the minimum of x and y in each row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = min(c(x, y, z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In this case you can use an existing vectorised function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(m = pmin(x, y, z))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Where these functions exist they'll be much faster than rowwise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # so be on the lookout for them.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # rowwise() is also useful when doing simulations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params &lt;- tribble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ~sim, ~n, ~mean, ~sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1,  1,     1,   1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2,  2,     2,   4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3,  3,    -1,   2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Here I supply variables to preserve after the computation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise(sim) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(z = rnorm(n, mean, sd))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want one row per simulation, put the results in a list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise(sim) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(z = list(rnorm(n, mean, sd)), .groups = "keep")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # sample_n() -&gt; slice_sample() ----------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Was:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 3, weight = w)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Now:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 3, weight_by = w)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that sample_n() would error if n was bigger than the group size</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_sample() will just use the available rows for consistency with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the other slice helpers like slice_head()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(sample_n(df, 10))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # sample_frac() -&gt; slice_sample() -------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Was:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_frac(df, 0.25)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_frac(df, 2, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Now:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, prop = 0.25)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, prop = 2, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars &lt;- as_tibble(mtcars) # for nicer printing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_all(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # NB: the transformation comes first in rename_with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> is_whole &lt;- function(x) all(floor(x) == x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_if(is_whole, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper, where(is_whole))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_at(vars(mpg:hp), toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper, mpg:hp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You now must select() and then rename</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_all(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Selection drops unselected variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_if(is_whole, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select(where(is_whole)) %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_at(vars(-contains("ar"), starts_with("c")), toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(!contains("ar") | starts_with("c")) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = 3:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intersect(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union_all(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df2, df1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> symdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setequal(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setequal(df1, df1[3:1, ])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that the following functions remove pre-existing duplicates:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = c(1:3, 3, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(3:5, 5))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intersect(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> symdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Similar to head(mtcars, 1):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Similar to tail(mtcars, 1):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(5:n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rows can be dropped with negative indices:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice(mtcars, -(1:4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # First and last rows based on existing order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_head(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_tail(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rows with minimum and maximum values of a variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(mpg, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_max(mpg, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_min() and slice_max() may return more rows than requested</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # in the presence of ties.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(cyl, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use with_ties = FALSE to return exactly n matches</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(cyl, n = 1, with_ties = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or use additional variables to break the tie:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(tibble(cyl, mpg), n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_sample() allows you to random select with or without replacement</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(n = 5, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you can optionally weight by a variable - this code weights by the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # physical weight of the cars, so heavy cars are more likely to get</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # selected</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(weight_by = wt, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group wise operation ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group = rep(c("a", "b", "c"), c(1, 2, 4)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = runif(7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # All slice helpers operate per group, silently truncating to the group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # size, so the following code works without error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(group) %&gt;% slice_head(n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When specifying the proportion of rows to include non-integer sizes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # are rounded down, so group a gets 0 rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(group) %&gt;% slice_head(prop = 0.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filter equivalents --------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice() expressions can often be written to use `filter()` and</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `row_number()`, which can also be translated to SQL. For many databases,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you'll need to supply an explicit variable to use to compute the row number.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, row_number() == 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, row_number() == n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, between(row_number(), 5, n()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> copy_to(con, mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To retrieve a single table from a source, use `tbl()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars &lt;- con %&gt;% tbl("mtcars")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also use pass raw SQL if you want a more sophisticated query</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> con %&gt;% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> storms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Show a few recent storm paths</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if (requireNamespace("ggplot2", quietly = TRUE)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   library(ggplot2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   storms %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     filter(year &gt;= 2000) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ggplot(aes(long, lat, color = paste(year, name))) +</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     geom_path(show.legend = FALSE) +</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     facet_wrap(~year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> storms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A summary applied to ungrouped tbl returns a single row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(mean = mean(disp), n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Usually, you'll want to group first</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(mean = mean(disp), n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Each summary call removes one grouping level (since that group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # is now just a single row)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl, vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(cyl_n = n()) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # BEWARE: reusing variables may lead to unexpected results</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(disp = mean(disp), sd = sd(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Refer to column names stored as strings with the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> var &lt;- "mass"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In dplyr 1.1.0, returning multiple rows per group was deprecated in favor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # of `reframe()`, which never messages and always returns an ungrouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # result:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _at() variants directly support strings:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_at(c("height", "mass"), mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% summarise(across(c("height", "mass"), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also supply selection helpers to _at() functions but you have</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to quote them with vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_at(vars(height:mass), mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(height:mass, ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _if() variants apply a predicate function (a function that</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returns TRUE or FALSE) to determine the relevant subset of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # columns. Here we apply mean() to the numeric columns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_if(is.numeric, mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species &lt;- iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to apply multiple transformations, pass a list of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # functions. When there are multiple functions, they create new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables instead of modifying the variables in place:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_all(list(min, max))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(everything(), list(min = min, max = max)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(x = c(6, 4, 1, 10, 3, 1, 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_n(2)  # highest values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_n(-2) # lowest values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # now use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_max(x, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_min(x, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # top_frac() -&gt; prop argument of slice_min()/slice_max()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_frac(.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_max(x, prop = 0.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(g = c(1, 1, 2, 2, 3), x = runif(5))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Old</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   with_groups(g, mutate, x_mean = mean(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # New</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(x_mean = mean(x), .by = g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL</span>
<span class="r-in"><span><span class="fu">forgot_exmpls</span><span class="op">(</span><span class="va">dplyr</span>, <span class="va">count</span>, write <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For better printing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # across() -----------------------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Different ways to select the same set of columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # See &lt;https://tidyselect.r-lib.org/articles/syntax.html&gt; for details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(c(Sepal.Length, Sepal.Width), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(c(1, 2), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(1:Sepal.Width, round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(where(is.double) &amp; !c(Petal.Length, Petal.Width), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Using an external vector of names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cols &lt;- c("Sepal.Length", "Petal.Width")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(all_of(cols), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the external vector is named, the output columns will be named according</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to those names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> names(cols) &lt;- tolower(cols)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(all_of(cols), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A purrr-style formula</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A named list of functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use the .names argument to control the output names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), mean, .names = "mean_{.col}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd), .names = "{.col}.{.fn}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a named external vector is used for column selection, .names will use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # those names when constructing the output names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(all_of(cols), mean, .names = "mean_{.col}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When the list is not named, .fn is replaced by the function's position</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(starts_with("Sepal"), list(mean, sd), .names = "{.col}.fn{.fn}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When the functions in .fns return a data frame, you typically get a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # "packed" data frame back</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(quantile = probs, value = quantile(x, probs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use .unpack to automatically expand these packed data frames into their</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # individual columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df, .unpack = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # .unpack can utilize a glue specification if you don't like the defaults</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(across(starts_with("Sepal"), quantile_df, .unpack = "{outer}.{inner}"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is also useful inside mutate(), for example, with a multi-lag helper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> multilag &lt;- function(x, lags = 1:3) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   names(lags) &lt;- as.character(lags)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   purrr::map_dfr(lags, lag, x = x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(starts_with("Sepal"), multilag, .unpack = TRUE)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(Species, starts_with("Sepal"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # if_any() and if_all() ----------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(if_any(ends_with("Width"), ~ . &gt; 4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(if_all(ends_with("Width"), ~ . &gt; 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scramble &lt;- function(x) x[sample(nrow(x)), sample(ncol(x))]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `all_equal()` ignored row and column ordering by default,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # but we now feel that that makes it too easy to make mistakes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars2 &lt;- scramble(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all_equal(mtcars, mtcars2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Instead, be explicit about the row and column ordering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all.equal(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mtcars,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mtcars2[rownames(mtcars), names(mtcars)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(mtcars, cyl, disp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(mtcars, desc(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # grouped arrange ignores groups</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% arrange(desc(wt))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unless you specifically ask:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% arrange(desc(wt), .by_group = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use embracing when wrapping in a function;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see ?rlang::args_data_masking for more details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tidy_eval_arrange &lt;- function(.data, var) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .data %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     arrange({{ var }})</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tidy_eval_arrange(mtcars, mpg)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `across()` or `pick()` to select columns with tidy-select</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% arrange(pick(starts_with("Sepal")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% arrange(across(starts_with("Sepal"), desc))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- as_tibble(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange_all(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange_all(df, desc)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, across(everything(), desc))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_instruments</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_instruments2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> between(1:12, 7, 9)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- rnorm(1e2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x[between(x, -1, 1)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # On a tibble using `filter()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, between(height, 100, 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(y = 3:1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_cols(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Row sizes must be compatible when column-binding</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:2, y = letters[1:2])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = 4:5, z = 1:2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can supply individual data frames as arguments:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or a list of data frames:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(df1, df2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When you supply a column name with the `.id` argument, a new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # column is created to link each row to its original data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(df1, df2), .id = "id")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> bind_rows(list(a = df1, b = df2), .id = "id")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sum = sum(c_across(w:z)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     sd = sd(c_across(w:z))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c("a", "b", "a", "d", "b", NA, "c", "e")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` acts like a vectorized `switch()`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unmatched values "fall through" as a missing value.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "a" ~ 1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "b" ~ 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c" ~ 3,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "d" ~ 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Missing values can be matched exactly, and `.default` can be used to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # control the value used for unmatched values of `.x`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "a" ~ 1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "b" ~ 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "c" ~ 3,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "d" ~ 4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   NA ~ 0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = 100</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Input values can be grouped into the same expression to map them to the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # same output value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c("a", "b") ~ "low",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c("c", "d", "e") ~ "high"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` isn't limited to character input:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(1, 2, 1, 3, 1, NA, 2, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(1, 3) ~ "odd",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(2, 4) ~ "even",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "missing"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Setting `.default` to the original vector is a useful way to replace</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # selected values, leaving everything else as is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(y, NA ~ 0, .default = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     # Replace missings, but leave everything else alone</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     # Replace some, but not all, of the species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     species = case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       species,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       "Human" ~ "Humanoid",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       "Droid" ~ "Robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       c("Wookiee", "Ewok") ~ "Hairy",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       .default = species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .keep = "used"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:70</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Like an if statement, the arguments are evaluated in order, so you must</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # proceed from the most specific to the most general. This won't work:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %%  5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %%  7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If none of the cases match and no `.default` is supplied, NA is used:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that `NA` values on the LHS are treated like `FALSE` and will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # assigned the `.default` value. You must handle them explicitly if you</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # want to use a different value. The exact way to handle missing values is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # dependent on the set of LHS conditions you use.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x[2:4] &lt;- NA_real_</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 35 == 0 ~ "fizz buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 5 == 0 ~ "fizz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x %% 7 == 0 ~ "buzz",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   is.na(x) ~ "nope",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = as.character(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` evaluates all RHS expressions, and then constructs its</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # result by extracting the selected (via the LHS expressions) parts.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In particular `NaN`s are produced in this case:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- seq(-2, 2, by = .5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y &gt;= 0 ~ sqrt(y),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = y</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` is particularly useful inside `mutate()` when you want to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # create a new variable that relies on a complex combination of existing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name:mass, gender, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     type = case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` is not a tidy eval function. If you'd like to reuse</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the same patterns, extract the `case_when()` call in a normal</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type &lt;- function(height, mass, species) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type(150, 250, "Droid")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type(150, 150, "Droid")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Such functions can be used inside `mutate()` as well:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(type = case_character_type(height, mass, species)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_when()` ignores `NULL` inputs. This is useful when you'd</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # like to use a pattern only under certain conditions. Here we'll</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # take advantage of the fact that `if` returns `NULL` when there is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # no `else` clause:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_character_type &lt;- function(height, mass, species, robots = TRUE) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   case_when(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height &gt; 200 | mass &gt; 200 ~ "large",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (robots) species == "Droid" ~ "robot",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .default = "other"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(type = case_character_type(height, mass, species, robots = FALSE)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrap_dbplyr_obj("build_sql")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrap_dbplyr_obj("base_agg")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use a single value to replace all missing values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- sample(c(1:5, NA, NA, NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(x, 0L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The equivalent to a missing value in a list is `NULL`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(list(1, 2, NULL), list(NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or generate a complete vector from partially missing pieces</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(1, 2, NA, NA, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(NA, NA, 3, 4, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(y, z)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Supply lists by splicing them into dots:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vecs &lt;- list(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(1, 2, NA, NA, 5),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   c(NA, NA, 3, 4, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> coalesce(!!!vecs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> f1 &lt;- factor("a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> f2 &lt;- factor("b")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> combine(f1, f2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vctrs::vec_c(f1, f1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> combine(list(f1, f2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vctrs::vec_c(!!!list(f1, f2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars2 &lt;- dbplyr::src_memdb() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   copy_to(mtcars, name = "mtcars2-cc", overwrite = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> remote &lt;- mtcars2 %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(cyl == 8) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(mpg:drat)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute query and save in remote table</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> compute(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute query bring back to this session</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> collect(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Creates a fresh query based on the generated SQL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> collapse(remote)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(x, y) %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(id = consecutive_id(x, y), x, y) %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = sample(rep(letters[1:3], 1:3)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = runif(6),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = runif(6)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf &lt;- df %&gt;% group_by(g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% mutate(id = cur_group_id())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% reframe(row = cur_group_rows())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% summarise(data = list(cur_group()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf %&gt;% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontrun{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris2 &lt;- dbplyr::src_memdb() %&gt;% copy_to(iris, overwrite = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # count() is a convenient way to get a sense of the distribution of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # values in a dataset</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(species, sort = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(sex, gender, sort = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% count(birth_decade = round(birth_year, -1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use the `wt` argument to perform a weighted count. This is useful</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # when the data has already been aggregated once</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tribble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~name,    ~gender,   ~runs,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Max",    "male",       10,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Sandra", "female",      1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   "Susan",  "female",      4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # counts rows:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(gender)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # counts runs:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(gender, wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When factors are involved, `.drop = FALSE` can be used to retain factor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # levels that don't appear in the data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = 1:5,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   type = factor(c("a", "c", "a", NA, "a"), levels = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% count(type)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% count(type, .drop = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or, using `group_by()`:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% group_by(type, .drop = FALSE) %&gt;% count()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tally() is a lower-level function that assumes you've done the grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% tally()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% group_by(species) %&gt;% tally()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # both count() and tally() have add_ variants that work like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mutate() instead of summarise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% add_count(gender, wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% add_tally(wt = runs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Cross joins match each row in `x` to every row in `y`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Data within the columns is not used in the matching process.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cross_join(band_instruments, band_members)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Control the suffix added to variables duplicated in</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `x` and `y` with `suffix`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cross_join(band_instruments, band_members, suffix = c("", "_y"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cummean()` returns a numeric/integer vector of the same length</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # as the input vector.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, 3, 5, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cummean(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumsum(x) / seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cumall()` and `cumany()` return logicals</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumall(x &lt; 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cumany(x == 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `cumall()` vs. `cumany()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   date = as.Date("2020-01-01") + 0:6,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   balance = c(100, 50, 25, -25, -50, 30, 120)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all rows after first overdraft</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% filter(cumany(balance &lt; 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all rows until first overdraft</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% filter(cumall(!(balance &lt; 0)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(1:10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(factor(letters))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first_day &lt;- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> desc(first_day)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% arrange(desc(mass))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dim_desc(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = sample(10, 100, rep = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = sample(10, 100, rep = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(distinct(df))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nrow(distinct(df, x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can choose to keep all other variables as well</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, x, .keep_all = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, y, .keep_all = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also use distinct on computed variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, diff = abs(x - y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `pick()` to select columns with tidy-select</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(starwars, pick(contains("color")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Grouping -------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = c(1, 1, 2, 2, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(1, 1, 2, 1, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(3, 2, 1, 3, 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- df %&gt;% group_by(g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # With grouped data frames, distinctness is computed within each group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% distinct(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When `...` are omitted, `distinct()` still computes distinctness using</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # all variables in the data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% distinct()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_all(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_at(df, vars(x,y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_if(df, is.numeric)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, pick(where(is.numeric)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can supply a function that will be applied before extracting the distinct values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The variables of the sorted tibble keep their original values.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct_all(df, round)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> distinct(df, across(everything(), round))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # do() with unnamed arguments becomes reframe() or summarise()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # . becomes pick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% do(head(., 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% reframe(head(pick(everything()), 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% slice_head(n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Can refer to variables directly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% do(mean = mean(.$vs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% summarise(mean = mean(vs))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # do() with named arguments becomes nest_by() + mutate() &amp; list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- by_cyl %&gt;% do(mod = lm(mpg ~ disp, data = .))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   nest_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mod = list(lm(mpg ~ disp, data = data)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(rsq = summary(mod)$r.squared)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use broom to turn models into data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% do(data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   var = names(coef(.$mod)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   coef(summary(.$mod)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(broom::tidy(mod))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (dplyr:::has_minimum_stringi()) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c("a", "b", "C", "B", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Default locale is C, which groups the English alphabet by case, placing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # uppercase letters before lowercase letters.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The American English locale groups the alphabet by letter.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Explicitly override `.locale` with `"en"` for this ordering.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "en")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This Danish letter is expected to sort after `z`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c("o", "p", "\u00F8", "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The American English locale sorts it right after `o`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "en")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Using `"da"` for Danish ordering gives the expected result</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(df, x, .locale = "da")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you need the legacy behavior of `arrange()`, which respected the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # system locale, then you can set the global option `dplyr.legacy_locale`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # but expect this to be removed in the future. We recommend that you use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the `.locale` argument instead.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rlang::with_options(dplyr.legacy_locale = TRUE, {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   arrange(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \donttest{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lahman_s &lt;- dbplyr::lahman_sqlite()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting &lt;- tbl(lahman_s, "Batting")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% show_query()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The batting database has indices on all ID variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # SQLite automatically picks the most restrictive index</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% filter(lgID == "NL" &amp; yearID == 2000L) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # OR's will use multiple indexes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% filter(lgID == "NL" | yearID == 2000) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Joins will use indexes in both tables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> teams &lt;- tbl(lahman_s, "Teams")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> batting %&gt;% left_join(teams, c("yearID", "teamID")) %&gt;% explain()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # "Filtering" joins keep cases from the LHS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% semi_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% anti_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To suppress the message about joining variables, supply `by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% semi_join(band_instruments, by = join_by(name))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is good practice in production code</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filtering by one criterion</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, species == "Human")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, mass &gt; 1000)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filtering by multiple criteria within a single logical expression</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none" &amp; eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none" | eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When multiple expressions are used, they are combined using &amp;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(starwars, hair_color == "none", eye_color == "black")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The filtering operation may yield different results on grouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tibbles because the expressions are computed within groups.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The following filters rows where `mass` is greater than the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # global average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Whereas this keeps rows with `mass` greater than the gender</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% group_by(gender) %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To refer to column names that are stored as strings, use the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vars &lt;- c("mass", "height")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cond &lt;- c(80, 150)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .data[[vars[[1]]]] &gt; cond[[1]],</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .data[[vars[[2]]]] &gt; cond[[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # While filter() accepts expressions with specific variables, the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # scoped filter verbs take an expression with the pronoun `.` and</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # replicate it over all variables. This expression should be quoted</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # with all_vars() or any_vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> all_vars(is.na(.))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> any_vars(is.na(.))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can take the intersection of the replicated expressions:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_all(mtcars, all_vars(. &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_all(everything(), ~ .x &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or the union:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_all(mtcars, any_vars(. &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_any(everything(), ~ . &gt; 150))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can vary the selection of columns on which to apply the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # predicate. filter_at() takes a vars() specification:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_at(mtcars, vars(starts_with("d")), any_vars((. %% 2) == 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_any(starts_with("d"), ~ (.x %% 2) == 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # And filter_if() selects variables with a predicate function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> is_int &lt;- function(x) all(floor(x) == x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, if_all(where(is_int), ~ .x != 0))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> funs("mean", mean(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list(mean = mean, mean = ~ mean(.x, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> funs(m1 = mean, m2 = "mean", m3 = mean(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list(m1 = mean, m2 = "mean", m3 = ~ mean(.x, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> glimpse(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that original x is (invisibly) returned, allowing `glimpse()` to be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # used within a pipeline.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   glimpse() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> glimpse(starwars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl &lt;- mtcars %&gt;% group_by(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # grouping doesn't change how the data looks (apart from listing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # how it's grouped):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It changes how it acts with the other dplyr verbs:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% summarise(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   disp = mean(disp),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   hp = mean(hp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;% filter(disp == max(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Each call to summarise() removes a layer of grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs_am &lt;- mtcars %&gt;% group_by(vs, am)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs &lt;- by_vs_am %&gt;% summarise(n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs %&gt;% summarise(n = sum(n))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To removing grouping, use ungroup</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_vs %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ungroup() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(n = sum(n))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, group_by() overrides existing grouping</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs, am) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use add = TRUE to instead append</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_cyl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs, am, .add = TRUE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can group by expressions: this is a short-hand</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # for a mutate() followed by a group_by()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vsam = vs + am)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The implicit mutate() step is always performed on the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # ungrouped data. Here we get 3 groups:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(hp_cut = cut(hp, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want it to be performed by groups,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you have to use an explicit mutate() call.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Here we get 3 groups per value of vs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(hp_cut = cut(hp, 3)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(hp_cut)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # when factors are involved and .drop = FALSE, groups can be empty</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = 1:10,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = factor(rep(c("a", "c"), each  = 5), levels = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(y, .drop = FALSE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_rows()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group a data frame by all variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_all(mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% group_by(pick(everything()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group by variables selected with a predicate:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_if(iris, is.factor)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% group_by(pick(where(is.factor)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group by variables selected by name:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_at(mtcars, vars(vs, am))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% group_by(pick(vs, am))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Like group_by(), the scoped variants have optional mutate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # semantics. This provide a shortcut for group_by() + mutate():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d &lt;- tibble(x=c(1,1,2,2), y=c(1,2,1,2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_all(d, as.factor)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> d %&gt;% group_by(across(everything(), as.factor))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_if(iris, is.factor, as.character)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% group_by(across(where(is.factor), as.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_by_drop_default(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by_drop_default()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species, .drop = FALSE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by_drop_default()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf &lt;- iris %&gt;% group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% select(group_cols())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Remove the grouping variables from mutate selections:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% mutate_at(vars(-group_cols()), `/`, 100)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt; No longer necessary with across()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gdf %&gt;% mutate(across(everything(), ~ . / 100))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = c(1,1,2,2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_vars(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_rows(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_data(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_indices(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> gf &lt;- group_by(df, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_vars(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_rows(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_data(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_indices(gf)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # return a list</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # return a tibble grouped by `cyl` with 2 rows per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the grouping data is recalculated</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a list of tibbles</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a restructured grouped tibble</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a list of vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to use group_modify() the lambda must return a data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      tibble::enframe(name = "prob", value = "quantile")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .x %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       purrr::map_dfc(fivenum) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       mutate(nms = c("min", "Q1", "median", "Q3", "max"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   })</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # group_walk() is for side effects</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dir.create(temp &lt;- tempfile())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> list.files(temp, pattern = "csv$")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> unlink(temp, recursive = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # group_modify() and ungrouped data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_modify(~ head(.x, 2L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #----- use case 1: a grouped data frame</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # this can be useful if the grouped data has been altered before nesting</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(Sepal.Length &gt; mean(Sepal.Length)) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #----- use case 2: using group_nest() on a ungrouped data frame with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #                  a grouping specification that uses the data mask</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_nest(species, homeworld)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ir &lt;- iris %&gt;% group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_split(ir)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> group_keys(ir)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   filter(Species == "setosa", .preserve = TRUE) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_trim()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Identifiers are escaped with "</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ident("x")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(-5:5, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x &lt; 0, NA, x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Explicitly handle `NA` values in the `condition` with `missing`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x &lt; 0, "negative", "positive", missing = "missing")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Unlike `ifelse()`, `if_else()` preserves types</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- factor(sample(letters[1:5], 10, replace = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ifelse(x %in% c("a", "b", "c"), x, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if_else(x %in% c("a", "b", "c"), x, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `if_else()` is often useful for creating new columns inside of `mutate()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(category = if_else(height &lt; 100, "short", "tall"), .keep = "used")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = c(1L, 1L, 1L, 2L, 2L),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> promos &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = c(1L, 1L, 2L),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> promos</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Match `id` to `id`, and `sale_date` to `promo_date`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, sale_date == promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For each `sale_date` within a particular `id`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # find all `promo_date`s that occurred before that particular sale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, sale_date &gt;= promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For each `sale_date` within a particular `id`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # find only the closest `promo_date` that occurred before that sale</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt;= promo_date))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to disallow exact matching in rolling joins, use `&gt;` rather</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # than `&gt;=`. Note that the promo on `2019-01-05` is no longer considered the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # closest match for the sale on the same date.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt; promo_date))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Same as before, but also require that the promo had to occur at most 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # day before the sale was made. We'll use a full join to see that id 2's</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sales &lt;- mutate(sales, sale_date_lower = sale_date - 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(id, closest(sale_date &gt;= promo_date), sale_date_lower &lt;= promo_date)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(sales, promos, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # ---------------------------------------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> segments &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   segment_id = 1:4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   chromosome = c("chr1", "chr2", "chr2", "chr1"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   start = c(140, 210, 380, 230),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   end = c(150, 240, 415, 280)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> segments</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> reference &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reference_id = 1:4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   chromosome = c("chr1", "chr1", "chr2", "chr2"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   start = c(100, 200, 300, 415),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   end = c(150, 250, 399, 450)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> reference</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment `start` falls between the reference</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `[start, end]` range.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, between(start, start, end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you wanted the reference columns first, supply `reference` as `x`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and `segments` as `y`, then explicitly refer to their columns using `x$`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and `y$`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, between(y$start, x$start, x$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(reference, segments, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment falls completely within a reference.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Sometimes using `x$` and `y$` makes your intentions clearer, even if they</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # match the default behavior.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, within(x$start, x$end, y$start, y$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> inner_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Find every time a segment overlaps a reference in any way.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It is common to have right-open ranges with bounds like `[)`, which would</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mean an end value of `415` would no longer overlap a start value of `415`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Setting `bounds` allows you to compute overlaps with those kinds of ranges.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = "[)"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> full_join(segments, reference, by)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:5</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tibble(behind = lag(x), x, ahead = lead(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to look more rows behind or ahead, use `n`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to define a value to pad with, use `default`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lag(1:5, default = 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lead(1:5, default = 6)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the data are not already ordered, use `order_by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scrambled &lt;- slice_sample(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(year = 2000:2005, value = (0:5) ^ 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   prop = 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrong &lt;- mutate(scrambled, previous_year_value = lag(value))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(wrong, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> right &lt;- mutate(scrambled, previous_year_value = lag(value, order_by = year))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(right, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% inner_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% left_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% right_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% full_join(band_instruments)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To suppress the message about joining variables, supply `by`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% inner_join(band_instruments, by = join_by(name))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is good practice in production code</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use an equality expression if the join variables have different names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;% full_join(band_instruments2, by = join_by(name == artist))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, the join keys from `x` and `y` are coalesced in the output; use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `keep = TRUE` to keep the join keys from both `x` and `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> band_members %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   full_join(band_instruments2, by = join_by(name == artist), keep = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a row in `x` matches multiple rows in `y`, all the rows in `y` will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returned once for each matching row in `x`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(1, 1, 2), y = c("first", "second", "third"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 %&gt;% left_join(df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If a row in `y` also matches multiple rows in `x`, this is known as a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # many-to-many relationship, which is typically a result of an improperly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # specified join or some kind of messy data. In this case, a warning is</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # thrown by default:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 &lt;- tibble(x = c(1, 1, 1, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 %&gt;% left_join(df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In the rare case where a many-to-many relationship is expected, set</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `relationship = "many-to-many"` to silence this warning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df3 %&gt;% left_join(df2, relationship = "many-to-many")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use `join_by()` with a condition other than `==` to perform an inequality</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # join. Here we match on every instance where `df1$x &gt; df2$x`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 %&gt;% left_join(df2, join_by(x &gt; x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, NAs match other NAs so that there are two</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # rows in the output of this join:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- data.frame(x = c(1, NA), y = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- data.frame(x = c(1, NA), z = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can optionally request that NAs don't match, giving a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a result that more closely resembles SQL joins</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> left_join(df1, df2, na_matches = "never")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Newly created variables are available immediately</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass2 = mass * 2,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass2_squared = mass2 * mass2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # As well as adding new variables, you can use mutate() to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # remove variables and modify existing variables.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, height, mass, homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mass = NULL,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     height = height * 0.0328084 # convert to feet</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use across() with mutate() to apply a transformation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to multiple columns in a tibble.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, homeworld, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(!name, as.factor))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see more in ?across</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Window functions are useful for grouped mutates:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(homeworld) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(rank = min_rank(desc(mass)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # see `vignette("window-functions")` for more details</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, new columns are placed on the far right.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1, y = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .before = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .after = x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, mutate() keeps all columns from the input data.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1, y = 2, a = "a", b = "b")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "all") # the default</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "used")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "unused")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(z = x + y, .keep = "none")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Grouping ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The mutate operation may yield different results on grouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tibbles because the expressions are computed within groups.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The following normalises `mass` by the global average:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Whereas this normalises `mass` by the averages within species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # levels:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, mass, species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(species) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Indirection ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Refer to column names stored as strings with the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vars &lt;- c("mass", "height")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # All variants can be passed functions and additional arguments,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # purrr-style. The _at() variants directly support strings. Here</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # we'll scale the variables `height` and `mass`:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scale2 &lt;- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), scale2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(c("height", "mass"), scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can pass additional arguments to the function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), scale2, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_at(c("height", "mass"), ~scale2(., na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(c("height", "mass"), ~ scale2(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also supply selection helpers to _at() functions but you have</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to quote them with vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_at(vars(matches("Sepal")), log)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(matches("Sepal"), log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _if() variants apply a predicate function (a function that</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returns TRUE or FALSE) to determine the relevant subset of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # columns. Here we divide all the numeric columns by 100:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate_if(is.numeric, scale2, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mutate_if() is particularly useful for transforming variables from</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # one type to another</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.factor, as.character)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.double, as.integer)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(where(is.factor), as.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate(across(where(is.double), as.integer))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Multiple transformations ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to apply multiple transformations, pass a list of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # functions. When there are multiple functions, they create new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables instead of modifying the variables in place:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale2, log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(~scale2(.), ~log(.)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale = scale2, log = log))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   as_tibble() %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(across(where(is.numeric), list(scale = scale2, log = log)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When there's only one function in the list, it modifies existing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables in place. Give it a name to instead create new variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% mutate_if(is.numeric, list(scale = scale2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, 1, 2, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c(3, 3, NA, 3, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(y, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Pairs (1, 3), (2, 3), and (2, NA) are distinct</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x, y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # (2, NA) is dropped, leaving 2 distinct combinations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(x, y, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Also works with data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> n_distinct(data.frame(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(1:5, 5:1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(1, -1, 0, 10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 100 / x</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 100 / na_if(x, 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- c("abc", "def", "", "ghi")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(y, "")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` allows you to replace `NaN` with `NA`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # even though `NaN == NaN` returns `NA`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(1, NaN, NA, 2, NaN)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> na_if(z, NaN)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` is particularly useful inside `mutate()`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and is meant for use with vectors rather than entire data frames</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(name, eye_color) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(eye_color = na_if(eye_color, "unknown"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_if()` can also be used with `mutate()` and `across()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to alter multiple columns</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    mutate(across(where(is.character), ~na_if(., "unknown")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sqrt(2) ^ 2 == 2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> near(sqrt(2) ^ 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # After nesting, you get one row per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris %&gt;% nest_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% nest_by(species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The output is grouped by row, which makes modelling particularly easy</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models &lt;- mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   nest_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(model = list(lm(mpg ~ wt, data = data)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(rsq = summary(model)$r.squared)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is particularly elegant with the broom functions</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% summarise(broom::glance(model))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(broom::tidy(model))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that you can also `reframe()` to unnest the data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> models %&gt;% reframe(data)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(2, 3, 3), y = c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out &lt;- nest_join(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> out$df2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # 5 bootstrap samples</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> tbl &lt;- new_grouped_df(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(x = rnorm(10)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   groups = tibble(".rows" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # mean of each bootstrap sample</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> summarise(tbl, x = mean(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 1:10</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- 10:1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, -2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `first()` and `last()` are often useful in `summarise()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = x, y = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     across(x:y, first, .names = "{col}_first"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     y_last = last(y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Selecting a position that is out of bounds returns a default value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 11)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 0)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This out of bounds behavior also applies to empty vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(integer())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can customize the default value with `default`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(x, 11, default = -1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(integer(), default = 0L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `order_by` provides optional ordering</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(x, order_by = y)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `na_rm` removes missing values before extracting the value</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> z &lt;- c(NA, NA, 1, 3, NA, 5, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(z)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(z, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> last(z, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(z, 3, na_rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For data frames, these select entire rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(a = 1:5, b = 6:10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> first(df)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> nth(df, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(x, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(x, 4)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If the bucket sizes are uneven, the larger buckets come first</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(1:8, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Ties are ignored</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ntile(rep(1, 8), 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> order_by(10:1, cumsum(1:10))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- 10:1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- 1:10</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> order_by(x, cumsum(y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(year = 2000:2005, value = (0:5) ^ 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> scrambled &lt;- df[sample(nrow(df)), ]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> wrong &lt;- mutate(scrambled, running = cumsum(value))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(wrong, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> right &lt;- mutate(scrambled, running = order_by(year, cumsum(value)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> arrange(right, year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> cume_dist(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> percent_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can understand what's going on by computing it by hand</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sapply(x, function(xi) sum(x &lt;= xi) / length(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sapply(x, function(xi) sum(x &lt; xi)  / (length(x) - 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The real computations are a little more complex in order to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # correctly deal with missing values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(3, 2, 2, 2, 1),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(0, 2, 1, 1, 4),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z1 = c("a", "a", "a", "b", "a"),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z2 = c("c", "d", "d", "a", "c")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `pick()` provides a way to select a subset of your columns using</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # tidyselect. It returns a data frame.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(cols = pick(x, y))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # This is useful for functions that take data frames as inputs.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For example, you can compute a joint rank between `x` and `y`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(rank = dense_rank(pick(x, y)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `pick()` is also useful as a bridge between data-masking functions (like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `mutate()` or `group_by()`) and functions with tidy-select behavior (like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `select()`). For example, you can use `pick()` to create a wrapper around</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `group_by()` that takes a tidy-selection of columns to group on. For more</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # bridge patterns, see</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> my_group_by &lt;- function(data, cols) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(data, pick({{ cols }}))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% my_group_by(c(x, starts_with("z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or you can use it to dynamically select columns to `count()` by</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% count(pick(starts_with("z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:3) p$pause(0.1)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p$tick()$print()$</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  pause(1)$stop()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If min_time is set, progress bar not shown until that many</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # seconds have elapsed</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(3, min_time = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:3) p$pause(0.1)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontrun{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> p &lt;- progress_estimated(10, min_time = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> for (i in 1:10) p$pause(0.5)$tick()$print()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(-1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% pull(cyl)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Also works for remote sources</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = "pull-ex")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mutate(z = x * y) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   pull()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Pull a named vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% pull(height, name)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> char_vec &lt;- sample(c("a", "b", "c"), 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode()` is superseded by `case_match()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(char_vec, a = "Apple", b = "Banana")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = char_vec)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # With `case_match()`, you don't need typed missings like `NA_character_`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Throws an error as `NA` is logical, not character.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(recode(char_vec, a = "Apple", b = "Banana", .default = NA))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` is easier to use with numeric vectors, because you don't</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # need to turn the numeric values into names</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> num_vec &lt;- c(1:4, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, `2` = 20L, `4` = 40L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `case_match()` doesn't have the ability to match by position like</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode()` does with numeric vectors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, "a", "b", "c", "d")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(c(1,5,3), "a", "b", "c", "d", .default = "nothing")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # For `case_match()`, incompatible types are an error rather than a warning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(num_vec, `2` = "b", `4` = "d")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(case_match(num_vec, 2 ~ "b", 4 ~ "d", .default = num_vec))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The factor method of `recode()` can generally be replaced with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `forcats::fct_recode()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> factor_vec &lt;- factor(c("a", "b", "c"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode(factor_vec, a = "Apple")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recode_factor()` does not currently have a direct replacement, but we</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # plan to add one to forcats. In the meantime, you can use the `.ptype`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # argument to `case_match()`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> recode_factor(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   num_vec,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `1` = "z",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `2` = "y",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   `3` = "x",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "D",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .missing = "M"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> case_match(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   num_vec,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   1 ~ "z",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   2 ~ "y",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   3 ~ "x",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   NA ~ "M",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .default = "D",</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   .ptype = factor(levels = c("z", "y", "x", "D", "M"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> table &lt;- c("a", "b", "d", "f")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   g = c(1, 1, 1, 2, 2, 2, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c("e", "a", "b", "c", "f", "d", "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `reframe()` allows you to apply functions that return</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # an arbitrary number of rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Functions are applied per group, and each group can return a</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # different number of rows.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table), .by = g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The output is always ungrouped, even when using `group_by()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(g) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(x = intersect(x, table))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can add multiple columns at once using a single expression by returning</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # a data frame.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     val = quantile(x, probs, na.rm = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     quant = probs</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(10, 15, 18, 12)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> quantile_df(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(quantile_df(height))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(quantile_df(height), .by = homeworld)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     across(c(height, mass), quantile_df, .unpack = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     .by = homeworld</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(f)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(a, .after = c)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(f, .before = b)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(a, .after = last_col())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # relocated columns can change name</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(ff = f)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Can also select variables based on their type</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(where(is.numeric), .after = last_col())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or with any other select helper</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% relocate(any_of(c("a", "e", "i", "o", "u")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When .before or .after refers to multiple variables they will be</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # moved to be immediately before/after the selected variables.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(a = 1, b = "a", c = 1, d = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% relocate(where(is.numeric), .after = where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 %&gt;% relocate(where(is.numeric), .before = where(is.character))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> iris &lt;- as_tibble(iris) # so it prints a little nicer</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, petal_length = Petal.Length)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rename using a named vector and `all_of()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lookup &lt;- c(pl = "Petal.Length", sl = "Sepal.Length")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, all_of(lookup))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If your named vector might contain names that don't exist in the data,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use `any_of()` instead</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> lookup &lt;- c(lookup, new = "unknown")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rename(iris, all_of(lookup)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename(iris, any_of(lookup))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, toupper, starts_with("Petal"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(iris, ~ tolower(gsub(".", "_", .x, fixed = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (getRversion() &gt; "4.0.1") (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If your renaming function uses `paste0()`, make sure to set</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `recycle0 = TRUE` to ensure that empty selections are recycled correctly</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rename_with(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   iris,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~ paste0("prefix_", .x),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   starts_with("nonexistent")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> ))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rename_with(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   iris,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   ~ paste0("prefix_", .x, recycle0 = TRUE),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   starts_with("nonexistent")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> x &lt;- c(5, 1, 3, 2, 2, NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> row_number(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> min_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> dense_rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Ranking functions can be used in `filter()` to select top/bottom rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = c(3, 2, 1, 1, 2, 2, 1, 1, 1),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y = c(1, 3, 2, 3, 2, 2, 4, 1, 2),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   id = 1:9</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Always gives exactly 1 row per group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(row_number(x) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # May give more than 1 row if ties</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(min_rank(x) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rank by multiple columns (to break ties) by selecting them with `pick()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(min_rank(pick(x, y)) == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # See slice_min() and slice_max() for another way to tackle the same problem</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can use row_number() without an argument to refer to the "current"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # row number.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% filter(row_number() == 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # It's easiest to see what this does with mutate():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(grp) %&gt;% mutate(grp_id = row_number())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data &lt;- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Insert</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_insert(data, tibble(a = 4, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, if a key in `y` matches a key in `x`, then it can't be inserted</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # and will throw an error. Alternatively, you can ignore rows in `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # containing keys that conflict with keys in `x` with `conflict = "ignore"`,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # or you can use `rows_append()` to ignore keys entirely.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rows_insert(data, tibble(a = 3, b = "z")))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_insert(data, tibble(a = 3, b = "z"), conflict = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_append(data, tibble(a = 3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Update</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, tibble(a = 2:3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, tibble(b = "z", a = 2:3), by = "a")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Variants: patch and upsert</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_patch(data, tibble(a = 2:3, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_upsert(data, tibble(a = 2:4, b = "z"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Delete and truncate</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, tibble(a = 2:3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, tibble(a = 2:3, b = "b"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # By default, for update, patch, and delete it is an error if a key in `y`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # with `unmatched = "ignore"`.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> y &lt;- tibble(a = 3:4, b = "z")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(rows_update(data, y, by = "a"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_update(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_patch(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> rows_delete(data, y, by = "a", unmatched = "ignore")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = runif(6), y = runif(6), z = runif(6))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute the mean of x, y, z in each row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # use c_across() to more easily select many variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = mean(c_across(x:z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Compute the minimum of x and y in each row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% rowwise() %&gt;% mutate(m = min(c(x, y, z)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In this case you can use an existing vectorised function:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(m = pmin(x, y, z))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Where these functions exist they'll be much faster than rowwise</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # so be on the lookout for them.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # rowwise() is also useful when doing simulations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params &lt;- tribble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  ~sim, ~n, ~mean, ~sd,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     1,  1,     1,   1,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     2,  2,     2,   4,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     3,  3,    -1,   2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Here I supply variables to preserve after the computation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise(sim) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   reframe(z = rnorm(n, mean, sd))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want one row per simulation, put the results in a list()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> params %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rowwise(sim) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(z = list(rnorm(n, mean, sd)), .groups = "keep")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # sample_n() -&gt; slice_sample() ----------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Was:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_n(df, 3, weight = w)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Now:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 10, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 3, weight_by = w)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that sample_n() would error if n was bigger than the group size</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_sample() will just use the available rows for consistency with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # the other slice helpers like slice_head()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> try(sample_n(df, 10))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, n = 10)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # sample_frac() -&gt; slice_sample() -------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Was:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_frac(df, 0.25)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> sample_frac(df, 2, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Now:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, prop = 0.25)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice_sample(df, prop = 2, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars &lt;- as_tibble(mtcars) # for nicer printing</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_all(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # NB: the transformation comes first in rename_with</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> is_whole &lt;- function(x) all(floor(x) == x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_if(is_whole, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper, where(is_whole))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_at(vars(mpg:hp), toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper, mpg:hp)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You now must select() and then rename</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_all(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Selection drops unselected variables:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_if(is_whole, toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select(where(is_whole)) %&gt;% rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% select_at(vars(-contains("ar"), starts_with("c")), toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   select(!contains("ar") | starts_with("c")) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   rename_with(toupper)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = 1:3)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = 3:5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intersect(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union_all(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df2, df1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> symdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setequal(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setequal(df1, df1[3:1, ])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Note that the following functions remove pre-existing duplicates:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df1 &lt;- tibble(x = c(1:3, 3, 3))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df2 &lt;- tibble(x = c(3:5, 5))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> intersect(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> union(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> setdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> symdiff(df1, df2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Similar to head(mtcars, 1):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Similar to tail(mtcars, 1):</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice(5:n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rows can be dropped with negative indices:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> slice(mtcars, -(1:4))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # First and last rows based on existing order</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_head(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_tail(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Rows with minimum and maximum values of a variable</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(mpg, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_max(mpg, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_min() and slice_max() may return more rows than requested</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # in the presence of ties.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(cyl, n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Use with_ties = FALSE to return exactly n matches</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(cyl, n = 1, with_ties = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Or use additional variables to break the tie:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_min(tibble(cyl, mpg), n = 1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice_sample() allows you to random select with or without replacement</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(n = 5, replace = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you can optionally weight by a variable - this code weights by the</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # physical weight of the cars, so heavy cars are more likely to get</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # selected</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;% slice_sample(weight_by = wt, n = 5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Group wise operation ----------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group = rep(c("a", "b", "c"), c(1, 2, 4)),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   x = runif(7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> )</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # All slice helpers operate per group, silently truncating to the group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # size, so the following code works without error</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(group) %&gt;% slice_head(n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # When specifying the proportion of rows to include non-integer sizes</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # are rounded down, so group a gets 0 rows</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% group_by(group) %&gt;% slice_head(prop = 0.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Filter equivalents --------------------------------------------</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # slice() expressions can often be written to use `filter()` and</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # `row_number()`, which can also be translated to SQL. For many databases,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # you'll need to supply an explicit variable to use to compute the row number.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, row_number() == 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, row_number() == n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> filter(mtcars, between(row_number(), 5, n()))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{if (requireNamespace("dbplyr", quietly = TRUE) &amp;&amp; requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() &gt;= "3.4") withAutoprint else force)({ # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> copy_to(con, mtcars)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # To retrieve a single table from a source, use `tbl()`</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars &lt;- con %&gt;% tbl("mtcars")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also use pass raw SQL if you want a more sophisticated query</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> con %&gt;% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> \dontshow{}) # examplesIf}</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> storms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Show a few recent storm paths</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> if (requireNamespace("ggplot2", quietly = TRUE)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   library(ggplot2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   storms %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     filter(year &gt;= 2000) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ggplot(aes(long, lat, color = paste(year, name))) +</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     geom_path(show.legend = FALSE) +</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     facet_wrap(~year)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> storms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # A summary applied to ungrouped tbl returns a single row</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(mean = mean(disp), n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Usually, you'll want to group first</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(mean = mean(disp), n = n())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Each summary call removes one grouping level (since that group</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # is now just a single row)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl, vs) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(cyl_n = n()) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_vars()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # BEWARE: reusing variables may lead to unexpected results</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(disp = mean(disp), sd = sd(disp))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Refer to column names stored as strings with the `.data` pronoun:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> var &lt;- "mass"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Learn more in ?rlang::args_data_masking</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # In dplyr 1.1.0, returning multiple rows per group was deprecated in favor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # of `reframe()`, which never messages and always returns an ungrouped</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # result:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> mtcars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    group_by(cyl) %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _at() variants directly support strings:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_at(c("height", "mass"), mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;% summarise(across(c("height", "mass"), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # You can also supply selection helpers to _at() functions but you have</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # to quote them with vars():</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_at(vars(height:mass), mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(height:mass, ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # The _if() variants apply a predicate function (a function that</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # returns TRUE or FALSE) to determine the relevant subset of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # columns. Here we apply mean() to the numeric columns:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_if(is.numeric, mean, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> starwars %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species &lt;- iris %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   group_by(Species)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # If you want to apply multiple transformations, pass a list of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # functions. When there are multiple functions, they create new</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # variables instead of modifying the variables in place:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise_all(list(min, max))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> by_species %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   summarise(across(everything(), list(min = min, max = max)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL NULL NULL NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- data.frame(x = c(6, 4, 1, 10, 3, 1, 1))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_n(2)  # highest values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_n(-2) # lowest values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # now use</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_max(x, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_min(x, n = 2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # top_frac() -&gt; prop argument of slice_min()/slice_max()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% top_frac(.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # -&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% slice_max(x, prop = 0.5)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL NULL </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df &lt;- tibble(g = c(1, 1, 2, 2, 3), x = runif(5))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # Old</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;%</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   with_groups(g, mutate, x_mean = mean(x))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> # New</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> df %&gt;% mutate(x_mean = mean(x), .by = g)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  NULL</span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span><span class="fu">forgot_exmpls</span><span class="op">(</span><span class="st">"dplyr"</span>, <span class="st">"count"</span>, write <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Sam Parmar.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer></div>

  

  

  </body></html>

